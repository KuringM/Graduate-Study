# 定点数的乘法运算

计算器实现乘法运算的三种方式

1. 乘法运算电路(基于ALU、移位器、寄存器实现的乘法指令)
2. 用逻辑运算、加/减运算等效实现乘法(没有乘法指令)
3. 阵列乘法器

在计算机内, 实现乘法运算的三种常见方式对比:

- 阵列乘法器(快速乘法器中的一种) 的运算速度最快-可1个时钟内完成运算
- 由 ALU、移位器、寄存器、控制逻辑 组成的乘法电路运算速度较快-通常需多个时钟才能完成运算
- 可以使用移位运算、加/减运算 等效实现乘法, 但运算速度最慢

## 1. 乘法运算的基本原理

无符号整数(二进制)的手算方法与十进制类似--**"逐位相乘, 错位相加"**.

$$
 1101 \times 1011 =
 (1101 \times 1 \times 2^3) +\\
 (1101 \times 0 \times 2^2) +\\
 (1101 \times 1 \times 2^1) +\\
 (1101 \times 1 \times 2^0)
$$

## 2. 无符号整数乘法运算电路(运算过程)

无符号整数乘法运算的逻辑结构图:
![[Pasted image 20250817170445.png]]

开始:

> 特殊情况:当被乘数、乘数中有一个为全0时, 结果直接得0, 不需要再进行后续的运算步骤

1. 将被乘数、乘数 分别放入寄存器X、Y
2. 乘积寄存器P(存放部分积)置为0
3. 计数器$C_n$的初始值置为 n (n 为乘数的位数)

重复 n 轮加法、移位运算, 直到计数器$C_n= 0$ :

1. 将**乘数寄存器Y的最低位**, 送入"控制逻辑"进行判断
   1. 若Y的最低位为1, 则执行加法, 运算结果写回P(注意加法产生的进位需保存至进位触发器C);
   2. 若Y的最低位为0, 则什么也不做.
2. 将[C, P, Y]视为整体, **逻辑右移一位**
3. 计数器$C_n$减1

结束(计数器$C_n = 0$):

1. 乘法运算的结果用 2n 位暂存(寄存器P、寄存器Y)
2. 在很多计算机架构中, 通常仅保留低 n 位作为乘积结果(因此, 运算结果可能发生**溢出**)

### 溢出判断

无符号整数乘法的溢出判断 :

两个 n bit *无符号整数*相乘, 运算结果用 2n bit 暂存. <BR>
通常仅保留低n位作为乘法运算结果. 若**高n位不全为0**, 说明发生溢出, 此时可将OF标志位(溢出标志位)置为1.

溢出的处理 :

1. 程序员可以选择忽略"溢出", 只不过这样会导致错误的运算结果
2. 如果想要处理"溢出" 这种"异常", 可以在乘法指令之后执行一条**溢出自陷指令**,
   (例如:x86 的 **INTO 指令(Interrupt on Overflow)**).
   该指令会检查 OF标志位, 若`OF==1`, 就执行操作系统的"**异常处理程序**"

## 3. 有符号整数乘法运算电路(运算过程)

> "补码一位乘法"由 A. D. Booth 提出, 因此这种算法也被称为布斯(Booth)乘法.

有符号整数乘法运算的逻辑结构图:

![[Pasted image 20250817180246.png]]

开始:

> 特殊情况:当被乘数、乘数中有一个为全0时, 结果直接得0, 不需要再进行后续的运算步骤

1. 将被乘数、乘数 分别放入寄存器X、Y
2. 乘积寄存器P置为0, "**辅助位**"置为0
3. 计数器$C_n$ 的初始值置为 n (n 为乘数的位数)

重复n轮加/减法、移位运算, 直到计数器$C_n = 0$ :

1. 将乘数寄存器Y的最低位、辅助位, 2bit 送入"控制逻辑"进行判断
2. 根据寄存器Y的最低位、辅助位, 决定是**+[x]补, -[x]补,+0**

   | 寄存器Y最低位 | 辅助位 |     本轮操作      |
   | :-----------: | :----: | :---------------: |
   |       0       |   0    |        +0         |
   |       0       |   1    | +[x]<sub>补</sub> |
   |       1       |   0    | -[x]<sub>补</sub> |
   |       1       |   1    |        +0         |

3. 将[P , Y, 辅助位]视为整体, **算数右移一位**
4. 计数器$C_n$减1

结束(计数器$C_n = 0$):

1. 乘法运算的结果用 2n 位暂存(寄存器P、寄存器Y)
2. 在很多计算机架构中, 通常仅保留低 n 位作为乘积结果(因此, 运算结果可能发生**溢出**)

### 溢出判断

带符号整数(补码)乘法的溢出判断 :

两个 n bit 带符号 整数 相乘, 运算结果用 2n bit 暂存. 通常仅保留低 n 位作为乘法运算结果. <BR>
若**高 n+1 位不完全相同**, 说明发生溢出, 此时可将 OF标志位(溢出标志位) 置为 1

溢出的处理 :

1. 程序员可以选择忽略"溢出", 只不过这样会导致错误的运算结果
2. 如果想要处理"溢出" 这种"异常", 可以在乘法指令之后执行一条溢出自陷指令,
   (例如:x86 的 **INTO 指令(Interrupt on Overflow)**).
   该指令会检查 OF标志位, 若`OF==1`, 就执行操作系统的"异常处理程序"

## 4. 列阵乘法器

![[Pasted image 20250818085756.png]]

特点:可以在1个时钟内完成乘法运算.

> 阵列乘法器是快速乘法器中的一种. 很多"快速乘法器"都可以在1个时钟内完成乘法运算.

## 5. 用逻辑运算、加/减运算等效实现乘法

思考:在一个没有乘法运算电路的计算机中, 能否用其他运算等效实现乘法?

```c
/*用移位运算、加法运算等效实现32bit无符号数乘法*/
unsigned int multiply_unsigned(unsigned int x,unsigned int y) {
	unsigned int result = 0;
	for (int i= 0;i < 32;i++){
		// 提取乘数 Y 的最低位
		unsigned int bit = y & 1;
		// 如果当前位为 1, 加上被乘数 ×
		if(bit){
			result += X;
		}
		//被乘数x 左移一位, 乘数 Y 右移一位
		X <<= 1;
		Y >>= 1;
	}
return result;
```

> 仅用到逻辑运算(位运算、移位运算), 加/减运算

优点:在没有乘法运算电路、不支持乘法指令的计算机中, 也可以等效实现乘法效果.

缺点:运算速度很慢(在非流水线计算机中, 每条指令的执行都至少需要1个时钟)

# 定点数的除法运算

对于除法电路, 建议重点关注:除法电路的**开始状态**、**结束状态**、**除法异常判断**.

## 1. 手算无符号整数除法

十进制上商规则:商×除数 的值, 要尽可能接近"中间余数", 但又不能大于中间余数.

二进制上商规则:商×除数 的值, 要尽可能接近"中间余数", 但又不能大于中间余数.换句话说, 如果中间余数 ≥ 除数, 则上商 1;否则上商 0

## 2. 无符号整数除法原理:

![[Pasted image 20250818095129.png]]

### 开始时

> 特殊情况:
>
> 1. 如果除数为0, 发生**除数为0异常**, 停止除法运算, 调出操作系统的异常处理程序; <BR>
> 2. 如果被除数小于除数, 则商为0, 余数等于被除数, 除法器不必再执行

1. **除数**放入**寄存器Y**;
2. **被除数**放入**寄存器[R,Q]** 并完成**零扩展**;
3. 寄存器$C_n$的初始值置为0

### 进行 1+n 轮处理(计算 1+n位商)

> 上商的规则:如果[R]-[Y］≥0、则上商1:否则上商0

第1轮特殊处理(商溢出判断)

> 第一位商不保存, 仅用于商溢出判断

- 直接上商, 若第一位商=1, 发生"**商溢出**"异常, 停止除法运算;
- 直接上商, 若第一位商=0, 说明不会发生"商溢出", 不必保存这位商, 也不让`Cn--`, 除法运算继续.

其余n轮处理

1. 先左移, 空出的位用于上商;
2. 上商, 背后的过程可能会进行: 加法(上商0, 恢复上轮中间余数(恢复余数法))/减法;
3. 计数器`Cn--`, 当计数器Cn=0时, 除法运算结.

### 结束

当计数器Cn=0 时, 除法运算结束.
n bit 寄存器[R]保存余数、n bit 寄存器[Q]保存商.

### 商溢出判断

该除法器支持

- 2n bit ÷ n bit (双精度除法): 商的实际位数有可能超过 n bit, 因此, **无符号整数的双精度除法可能发生"商溢出"**;
- n bit ÷ nbit(单精度除法): 商的实际位数不可能超过 n bit, 因此, **无符号整数单精度除法不可能发生"商溢出"**.

最终都仅保留 n bit 商、n bit 余数.

> 概念补充:在 x86 中, 除数为0、商溢出 都属于"除法错异常"(Divide Error Exception), 也可简译为"除法异常".

# 过程调用的机器级表示

## x86汇编语言的函数调用

函数的**栈帧(Stack Frame)**:保存函数大括号内定义的局部变量、保存函数调用相关的信息.

函数调用指令: `call <函数名>`
函数返回指令: `ret`

**call指令**的作用:

1. 将IP旧值压栈保存(保存在函数的栈帧顶部)
2. 设置IP新值, 无条件转移至被调用函数的第一条指令

**ret指令**的作用:

- 从函数的栈帧顶部找到 IP旧值, 将其出栈并恢复IP寄存器

## 函数调用栈在内存中的位置

![[Pasted image 20250821160430.png]]

### 标记栈帧范围:EBP、ESP寄存器

> 注:x86 系统中, 默认以4字节为栈的操作单位

- **ebp**:指向当前栈帧的"底部"
- **esp**:指向当前栈帧的"顶部"

### 访问栈帧数据:push、pop 指令

push、pop 指令实现入栈、出栈操作.

- `Push A`: 先让esp减4, 再将A压入, A可以是立即数、寄存器、主存地址
- `Pop B`: 栈顶元素出栈写入B, 再让 esp加4, B可以是寄存器、主存地址

例:

- `push eax`: 将寄存器eax的值压栈
- `push 985`: 将立即数985压栈
- `push [ebp+8]`: 将主存地址[ebp+8]里的数据压栈
- `pop eax`: 栈顶元素出栈, 写入寄存器eax
- `pop [ebp+8]`: 栈顶元素出栈, 写入主存地址[ebp+8]

### 访问栈帧数据:mov 指令

- 可以用 mov 指令, 结合 esp、ebp 指针访问栈帧数据
- 可以用减法/加法指令, 即 sub/add 修改栈顶指针 esp 的值

例:

- `sub esp, 12`: 栈顶指针-12
- `mov [esp+8], eax`: 将eax的值复制到主存[esp+8]
- `mov [esp+4], 958`: 将985复制到主存[esp+4]
- `mov eax, [ebp+8]`: 将主存[ebp+8]的值复制到eax
- `mov [esp],eax`: 将eax的值复制到主存[esp]
- `add esp, 8`: 栈顶指针+8

## 函数调用时, 如何切换栈帧?

> 除了main函数, 其他所有函数的汇编代码结构都一样!

调用者:

1. 保存必要的寄存器, 如eax、edx、ecx
2. 将调用参数写入当前栈帧的顶部区域, 可以用push或mov指令实现
3. **执行 call 指令**: 返回地址压入栈顶、并跳转到被调用函数第一条指令
4. 使用返回值, 通过eax寄存器
5. 恢复必要寄存器

被调用者:

1. 保存上一层函数栈帧, 设置当前函数栈帧
   > push ebp <BR>
   > mov ebp,esp <BR>
   > 或:enter指令
2. 初始化局部变量
3. 一系列处理逻辑
4. 向上层函数传递返回值, 通过eax寄存器
5. 恢复上一层函数的栈帧
   > mov esp, ebp <BR>
   > pop ebp <BR>
   > 或:leave指令
6. **执行 ret 指令**: 从栈顶找到返回地址,出栈并恢复 IP 值

## 一个栈帧内可能包含哪些内容?

- gcc 编译器将每个栈帧大小设置为 16B 的整数倍(当前函数的栈帧除外), 因此栈帧内可能出现空闲未使用的区域.
- 通常将**局部变量**集中存储在**栈帧底部区域**. (C语言中越靠前定义的局部变量越靠近栈顶)
- 通常将**调用参数**集中存储在**栈帧顶部区域** (参数列表中越靠前的参数越靠近栈顶)
- **栈帧最底部**一定是**上一层栈帧基址**(ebp旧值)
- **栈帧最顶部**一定是**返回地址**(当前函数的栈帧除外)

![[Pasted image 20250821163751.png]]


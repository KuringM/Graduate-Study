# 常见的数据寻址方式

## 1. 直接寻址

指令字中的形式地址A就是操作数的真实地址EA, 即`EA=A`.

![[Pasted image 20250820125651.png]]

## 2. 简介寻址

指令的地址字段给出的形式地址不是操作数的真正地址,
而是操作数有效地址所在的存储单元的地址, 也就是操作数地址的地址, 即`EA=(A)`.

![[Pasted image 20250820130216.png]]

## 3. 寄存器寻址

在指令字中直接给出操作数所在的寄存器编号, 即$EA =R_i$, 其操作数在由$R_i$所指的寄存器内.

![[Pasted image 20250820130441.png]]

## 4. 寄存器简介寻址

寄存器间接寻址:寄存器$R_i$中给出的不是一个操作数, 而是操作数所在主存单元的地址,即 $EA=(R_i)$.

![[Pasted image 20250820130638.png]]

## 5. 隐含寻址

不是明显地给出操作数的地址, 而是在指令中隐含着操作数的地址 .

![[Pasted image 20250820130742.png]]

## 6. 立即(数)寻址

形式地址A就是操作数本身, 又称为**立即数**, 一般采用补码形式.

> # 表示立即寻址特征.

![[截屏2025-08-20 13.10.13.png]]

---

> 7,8,9 统称偏移寻址 <BR>
> 基址寻址:以程序的起始存放地址作为"起点" <BR>
> 变址寻址:程序员自己决定从哪里作为"起点" <BR>
> 相对寻址:以程序计数器PC所指地址作为"起点"

## 7. 基址寻址

将CPU中**基址寄存器(BR, Base address Register)**的内容加上指令格式中的形式地址A, 而形成操作数的有效地址, 即$EA=(BR)+A$.

> Tips:可对比操作系统第三章第一节学习, OS课中的"重定位寄存器"就是"基址寄存器".

![[截屏2025-08-20 13.21.08.png]]

### 基址寻址的作用

注: 基址寄存器是**面向操作系统**的, 其内容由操作系统或管理程序确定.
在程序执行过程中, 基址寄存器的内容不变(作为基地址), 形式地址可变(作为偏移量).

当采用通用寄存器作为基址寄存器时, 可由用户决定哪个寄存器作为基址寄存器,但其内容仍由操作系统确定.

优点:

- 采用基址寻址无需修改指令中的地址码
- 便于程序"浮动", 方便实现多道程序并发运行.
- 可扩大寻址范围(基址寄存器的位数大于形式地址A的位数);
- 用户不必考虑自己的程序存于主存的哪一空间区域,故有利于多道程序设计, 以及可用于编制浮动程序(整个程序在内存里边的浮动) .

> 拓展:程序运行前, CPU将BR的值修改为该程序的起始地址(存在操作系统PCB中)

## 8. 变址寻址

有效地址EA等于指令字中的形式地址A与变址寄存器IX(Index Register)的内容相加之和, 即$EA= (IX)+A$, 其中IX可为变址寄存器(专用), 也可用通用寄存器作为变址寄存器.

变址寄存器是**面向用户**的, 在程序执行过程中, _变址寄存器的内容可由用户改变_(IX作为偏移量), 形式地址A不变(作为基地址).

![[Pasted image 20250820133548.png]]

### 变址寻址的作用

在数组处理过程中, 可设定A为数组的首地址, 不断改变变址寄存器IX的内容, 便可很容易形成数组中任一数据的地址, 特别适合编制循环程序.

优点:

在数组处理过程中, 可设定A为数组的首地址, 不断改变变址寄存器IX的内容,
便可很容易形成数组中任一数据的地址, 特别适合编制循环程序.

### 基址&变址复合寻址

实际应用中往往需要多种寻址方式复合使用(可理解为复合函数).

## 9. 相对寻址

把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址,
即$EA=(PC)+A$, 其中**A是相对于当前PC**所指地址的位移量, 可正可负, 补码表示.

![[Pasted image 20250820135316.png]]

> 图有误, 相对距离A应该是相对1002或1004, 而不是1000

### 相对寻址作用

优点:
操作数的地址不是固定的, 它随着PC值的变化而变化,
并且与指令地址之间总是相差一个固定值, 因此便于程序浮动(一段代码在程序内部的浮动).

> 拓展:ACC加法指令的地址码, 可采用"分段"方式解决, 即程序段、数据段分开. <BR>
> 相对寻址广泛应用于转移指令.

## 10. 堆栈寻址

操作数存放在堆栈中, 隐含使用**堆栈指针(SP)**作为操作数地址.

堆栈是存储器(或专用寄存器组)中一块特定的按"后进先出(LIFO)",
原则管理的存储区, 该存储区中被读/写单元的地址是用一个特定的寄存器给出的, 该寄存器称为堆栈指针(SP).

![[截屏2025-08-20 14.23.42.png]]

上述使用寄存器堆栈称为**硬堆栈**, 成本高, 不适合做大容量的堆栈.
通常采用从主存中化出一段区域来做**(软)堆栈**来实现.

> 堆栈可用于函数调用时保存当前函数的相关信息(可参考数据结构"算法空间复杂度"的视频).

![[截屏2025-08-20 14.31.55.png]]


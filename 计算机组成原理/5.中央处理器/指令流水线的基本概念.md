# 指令流水线的基本概念

一条指令的执行过程可以分成多个阶段(或过程).
根据计算机的不同, 具体的分法也不同.

- 取指(IF):根据PC内容访问主存储器, 取出一条指令送到IR中.
- 分析:对指令操作码进行译码, 按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA, 并从有效地址EA中取出操作数.
- 执行(EX):根据操作码字段, 完成指令规定的功能, 即把运算结果写到通用寄存器或主存中.

![[截屏2025-08-26 16.22.44.png]]

1. 顺序执行方式 总耗时 $T = n \times = 3nt$
2. 一次重叠执行方式 总耗时T = 3t + (n-1)×2t = (1+2n)t
3. 二次重叠执行方式 总耗时T = 3t + (n-1)×t = (2+n)t

## 五段式指令流水线

### 机器周期的设置

![[Pasted image 20250826170317.png]]

流水线每一个功能段部件后面都要有一个缓冲寄存器, 或称为锁存器, 其作用是保存本流水段的执行结果, 提供给下一流水段使用.

一条指令的执行过程分为如下5个阶段(功能段/流水段)

1. 取指(IF): 从指令寄存器或Cache中取指令
2. 译码/读寄存器(ID): 操作控制器对指令进行译码, 同时从寄存器堆中取操作数
3. 执行/计算地址(EX): 执行运算操作或计算地址
4. 访存(MEM): 对存储器进行读/写操作
5. 写回(WB): 将指令执行结果写回寄存器堆

考试中常见的五类指令: 运算类指令、LOAD指令、STORE指令、条件转移指令、无条件转移指令

### 运算类指令的执行过程

|        运算类指令举例         | 指令的汇编格式 |       功能        |
| :---------------------------: | :------------: | :---------------: |
|   加法指令(两个寄存器相加):   |   ADD Rs,Rd    | $(Rs)+(Rd)\to Rd$ |
| 加法指令(寄存器与立即数相加): |  ADD #996,Rd   | $996+(Rd)\to Rd$  |
|         算数左移指令:         |     SHL Rd     | $(Rd)<<<2\to Rd$  |

- IF:根据PC从指令Cache取指令至IF段的锁存器
- ID:取出操作数至ID段锁存器
- EX:运算, 将结果存入EX段锁存器
- M:空段
- WB:将运算结果写回指定寄存器

### LOAD指令的执行过程

|  指令的汇编格式   |        功能        |
| :---------------: | :----------------: |
| `LOAD Rd,996(Rs)` | $(996+(Rs))\to Rd$ |
|   `LOAD Rd,mem`   |   $(mem) \to Rd$   |

- IF:根据PC从指令Cache取指令至IF段的锁存器
- ID:将基址寄存器的值放到锁存器A, 将偏移量的值放到Imm
- EX:运算, 得到有效地址
- M:从数据Cache中取数并放入锁存器
- WB:将取出的数写回寄存器

> 通常, RISC处理器只有"取数LOAD"和"存数STORE"指令才能访问主存

### STORE指令的执行过程

|   指令的汇编格式   |        功能         |
| :----------------: | :-----------------: |
| `STORE Rs,996(Rd)` | $Rs \to (996+(Rs))$ |
|   `STORE Rs,mem`   |   $Rs \to (mem)$    |

- IF:根据PC从指令Cache取指令至IF段的锁存器
- ID:将基址寄存器的值放到锁存器A, 将偏移量的值放到Imm. 将要存的数放到B
- EX:运算, 得到有效地址. 并将锁存器B的内容放到锁存器 Store.
- M:写入数据Cache
- WB:空段

### 条件转移指令的执行过程

> 采用相对寻址 <BR>
> 注:通常在IF段结束止之后PC就会自动 +"1"

|    指令的汇编格式     |                                   功能                                    |
| :-------------------: | :-----------------------------------------------------------------------: |
| `beq Rs, Rt, #偏移量` | 若(Rs)==(Rt),则(PC)+指令字长+(偏移量×指令字长)->PC;否则(PC)+指令字长-> PC |
| `bne Rs, Rt, #偏移量` | 若(Rs)!=(Rt),则(PC)+指令字长+(偏移量×指令字长)->PC;否则(PC)+指令字长-> PC |

- IF:根据PC从指令Cache取指令至IF段的锁存器
- ID:进行比较的两个数放入锁存器A、B;偏移量放入 Imm
- EX:运算, 比较两个数
- M:将目标PC值写回PC(左图没画全)
- WB:空段

> 很多教材把写回PC的功能段称为"WrPC段", 其耗时比M段更短, 可安排在M段时间内完成

### 无条件转移指令的执行过程

> 转移类指令常采用相对寻址

| 指令的汇编格式 |                功能                 |
| :------------: | :---------------------------------: |
| `jmp #偏移量`  | (PC)+指令字长+(偏移量x指令字长)->PC |

- IF:根据PC从指令Cache取指令至IF段的锁存器
- ID:偏移量放入 Imm
- EX:将目标PC值写回PC(左图没画全)
- M:空段
- WB:空段

> "WrPC段"耗时比EX段更短, 可安排在EX段时间内完成.
> WrPC段越早完成, 就越能避免控制冲突.
> 当然, 也有的地方会在WB段时间内才修改PC的值

# Cache中主存块的替换算法

> 注意:每次被访问的主存块, 一定会被立即调入Cache

## 随机算法(RAND, Random)

若Cache已满, 则随机选择一块替换.
实现简单, 但完全没考虑局部性原理, 命中率低, 实际效果很不稳定.

![[截屏2025-08-19 19.25.18.png]]

## 先进先出算法(FIFO, First In First Out)

若Cache已满, 则替换最先被调入Cache 的块.

![[Pasted image 20250819193027.png]]

实现简单, 最开始按#0#1#2#3放入Cache, 之后轮流替换 #0#1#2#3.
FIFO依然没考虑**局部性原理**, 最先被调入Cache的块也有可能是被频繁访问的.

抖动现象: 频繁的换入换出现象(刚被替换的块很快又被调入).

## 近期最少使用算法(LRU, Least Recently Used) ‼️

为每一个Cache块设置一个**计数器(LRU替换位)**, 用于记录每个Cache块已经有多久没被访问了. 当Cache满后替换"计数器"最大的.

1. 命中时, 所命中的行的计数器清零, 比其低的计数器加1, 其余不变;
2. 未命中且还有空闲行时, 新装入的行的计数器置0, 其余非空闲行全加1;
3. 未命中且无空闲行时, 计数值最大的行的信息块被淘汰, 新装行的块的计数器置0, 其余全加1.

![[Pasted image 20250819194128.png]]

> Cache块的总数=$2^{n}$, 则计数器只需n位. 且Cache装满后所有计数器的值一定不重复.

基于"局部性原理", 近期被访问过的主存块, 在不久的将来也很有可能被再次访问,因此淘汰最久没被访问过的块是合理的. <BR>
LRU算法的实际运行效果优秀, Cache命中率高. <BR>
若被频繁访问的主存块数量 > Cache行的数量, 则有可能发生"抖动", 如:{1,2,3,4,5,1,2,3,4,5,1,2…}

## 最不经常使用算法(LFU, Least Frequently Used )

为每一个Cache块设置一个"计数器", 用于记录每个Cache块被访问过几次. 当Cache满后替换"计数器"最小的.

新调入的块计数器=0, 之后每被访问一次计数器+1. 需要替换时, 选择计数器最小的一行. <BR>
若有多个计数器最小的行, 可按行号递增、或FIFO策略进行选择.

![[Pasted image 20250819195019.png]]

曾经被经常访问的主存块在未来不一定会用到(如:微信视频聊天相关的块),
并没有很好地遵循局部性原理, 因此实际运行效果不如LRU.

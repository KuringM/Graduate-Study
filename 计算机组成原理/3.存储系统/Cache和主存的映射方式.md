# Cache和主存的映射方式

cache中存储的信息: 有效位(0/1)+ 标记+ 整块数据

假设某个计算机的主存**地址空间**大小为256MB, 按字节编址, 其数据Cache有8个**Cache行**, 行长为64B.

> Cache行即Cache块, 与主存块的大小相等.

- 256M= $2^{28}$: 主存可分为 $2^{22}$块, 主存的地址共28位

## 1. 全相联映射

主存块可以放在Cache的任意位置.

全相联映射的地址结构: `[标记][块内地址]`

| (标记)主存块号 | 块内地址 |
| -------------- | -------- |
| 22位           | 6位      |

![[Pasted image 20250819184501.png]]

优点

- Cache存储空间利用率高
- 命中率高
- 映射灵活
- 块冲突概率比较低

缺点

- 查找标记最慢, 有可能需要对比所有行的标记
- 成本高
- 速度慢耗时多

## 2. 直接映射

每个主存块只能放到一个特定的位置: `Cache块号=主存块号 mod Cache总块数`

若Cache总块数= $2^{n}$则主存块号末尾n位直接反映它在Cache中的位置.
将主存块号的其余块号主存位作为标记即可.

直接映射的地址结构: `[标记][Cache行号][块内地址]`

| 标记 | Cache行号 | 块内地址 |
| ---- | --------- | -------- |
| 19位 | 3位       | 6位      |

![[Pasted image 20250819185634.png]]

优点: 对于任意一个地址, 只需对比一个标记, 速度最快

缺点: Cache存储空间利用不充分, 命中率低

## 3. 组相联映射

Cache块分为若干组, 每个主存块可放到特定分组中的任意一个位置, `组号=主存块号 mod 分组数(Q)`

- `Q=1`, 变为全相联映射
- `Q=Cache行数`, 变为直接映射
- r路组相联, 即每组有r个cache行

组相联映射的地址结构: `[标记][组号][块内地址]`

![[Pasted image 20250819191129.png]]

| 标记 | Cache行号 | 块内地址 |
| ---- | --------- | -------- |
| 20位 | 2位       | 6位      |

优点: 另外两种方式的折中, 综合效果较好

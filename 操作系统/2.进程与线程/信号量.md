# 信号量

## 信号量机制

用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作, 从而很方便的实现了进程互斥、进程同步.

信号量其实就是一个变量 (可以是一个整数, 也可以是更复杂的记录型变量),
可以用一个信号量来表示系统中某种资源的数量, 比如: 系统中只有一台打印机, 就可以设置一个初值为 1 的信号量.

原语是一种特殊的程序段, 其执行只能一气呵成, 不可被中断.
原语是由关中断/开中断指令实现的.
软件解决方案的主要问题是由"进入区的各种操作无法一气呵成", 因此如果能把进入区、退出区的操作都用"原语"实现, 使这些操作能"一气呵成"就能避免问题.

一对原语: wait(S) 原语和 signal(S) 原语, 可以把原语理解为我们自己写的函数,
函数名分别为 wait和 signal, 括号里的信号量 S 其实就是函数调用时传入的一个参数.

wait、signal 原语常简称为 P、V操作(来自荷兰语 proberen 和 verhogen).
因此, 做题的时候常把wait(S)、signal(S) 两个操作分别写为 P(S)、V(S)

## 整型信号量

用一个整数型的变量作为信号量, 用来表示系统中某种资源的数量.

> 与普通整数变量的区别: 对信号量的操作只有三种, 即 初始化、P操作、V操作 <BR>
> Eg : 某计算机系统中有一台打印机...

## 记录型信号量

整型信号量的缺陷是存在"忙等"问题, 因此人们又提出了"记录型信号量", 即用记录型数据结构表示的信号量.

在考研题目中 wait(S)、signal(S) 也可以记为 P(S)、V(S), 这对原语可用于实现系统资源的"申请"和"释放".

S.value 的初值表示系统中某种资源的数目.

对信号量 S 的一次 P 操作意味着进程请求一个单位的该类资源, 因此需要执行 S.value--,
表示资源数减1, 当 `S.value < 0` 时表示该类资源已分配完毕,
因此进程应调用 block 原语进行自我阻塞(当前运行的进程从运行态 -> 阻塞态), 主动放弃处理机,
并插入该类资源的等待队列 S.L 中.
可见, 该机制遵循了"让权等待"原则,不会出现"忙等"现象.

对信号量 S 的一次 V 操作意味着进程释放一个单位的该类资源, 因此需要执行 S.value++, 表示资源数加1,
若加1后仍是 `S.value <= 0`, 表示依然有进程在等待该类资源,
因此应调用 wakeup 原语唤醒等待队列中的第一个进程(被唤醒进程从阻塞态à就绪态).

## 信号量机制实现进程互斥

用信号量实现进程同步:

1. 分析什么地方需要实现"同步关系", 即必须保证"一前一后"执行的两个操作(或两句代码)
2. 设置同步信号量 S, 初始为 0
3. 在"前操作"之后执行 V(S)
4. 在"后操作"之前执行 P(S)

## 信号量机制实现前驱关系

![[Pasted image 20251008160623.png]]


# 实现临界区互斥的基本方法

## 1. 软件实现方法

### 单标志法

算法思想:
两个进程在访问完临界区后 会把使用临界区的权限转交给另一个进程.
也就是说每个进程进入临界区的权限只能被另一个进程赋予.

### 双标志先检查法

算法思想:
设置一个布尔型数组 `flag[]`, 数组中各个元素用来标记各进程想进入临界区的意愿,
比如 `flag[0] = ture`意味着 0 号进程 P0 现在想要进入临界区. <BR>
每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区,
如果没有, 则把自身对应的标志 flag[i] 设为 true, 之后开始访问临界区.

### 双标志后检查法

算法思想:
双标志先检查法的改版.
前一个算法的问题是先"检查"后"上锁", 但是这两个操作又无法一气呵成, 因此导致了两个进程同时进入临界区的问题.
因此, 人们又想到先"上锁"后"检查"的方法, 来避免上述问题.

### Peterson 算法

算法思想:
结合双标志法、单标志法的思想.
如果双方都争着想进入临界区, 那可以让进程尝试"孔融让梨"(谦让). 做一个有礼貌的进程.

Peterson 算法用软件方法解决了进程互斥问题, 遵循了空闲让进、忙则等待、有限等待 三个原则,
但是依然未遵循让权等待的原则.

Peterson 算法相较于之前三种软件解决方案来说, 是最好的, 但依然不够好.

## 2. 硬件实现方法

### 中断屏蔽方法

利用"开/关中断指令"实现(与原语的实现思想相同, 即在某进程开始访问临界区到结束访问为止都不允许被中断,
也就不能发生进程切换, 因此也不可能发生两个同时访问临界区的情况)

关中断后即不允许当前进程被中断, 也必然不会发生进程切换
直到当前进程访问完临界区, 再执行开中断指令, 才有可能有别的进程上处理机并访问临界区

- 优点: 简单、高效
- 缺点: 不适用于多处理机;只适用于操作系统内核进程, 不适用于用户进程(因为开/关中断指令只能运行在内核态, 这组指令如果能让用户随意使用会很危险)

### TestAndSet指令

简称 TS 指令, 也有地方称为 TestAndSetLock 指令, 或 TSL 指令.

TSL 指令是用硬件实现的, 执行的过程不允许被中断, 只能一气呵成. 以下是用C语言描述的逻辑.

### Swap指令

有的地方也叫 Exchange 指令, 或简称 XCHG 指令.
Swap 指令是用硬件实现的, 执行的过程不允许被中断, 只能一气呵成. 以下是用C语言描述的逻辑.

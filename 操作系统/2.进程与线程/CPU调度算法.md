# CPU调度算法

## 先来先服务(FCFS, First Come First Serve)

先来先服务调度算法: 按照到达的先后顺序调度, 事实上就是等待时间越久的越优先得到服务.

![[Pasted image 20251007155729.png]]

## 短作业优先(SJF, Shortest Job First)

短作业/进程优先调度算法: 每次调度时选择当前已到达且运行时间最短的作业/进程.

> 对比FCFS算法的结果, 显然SPF算法的平均等待/周转/带权周转时间都要更低.

最短剩余时间优先算法:

- 每当有进程加入就绪队列改变时就需要调度,
- 如果新到达的进程剩余时间比当前运行的进程剩余时间更短, 则由新进程抢占处理机, 当前运行进程重新回到就绪队列.
- 另外, 当一个进程完成时也需要调度

> 抢占式的短作业优先算法又称"最短剩余时间优先算法(SRTN)".

注意几个小细节:

1. 如果题目中未特别说明, 所提到的"短作业/进程优先算法"默认是非抢占式的
2. 很多书上都会说"SJF 调度算法的平均等待时间、平均周转时间最少"
   - 严格来说, 这个表述是错误的, 不严谨的. 之前的例子表明, 最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少;
   - 应该加上一个条件"在所有进程同时可运行时, 采用SJF调度算法的平均等待时间、平均周转时间最少";
   - 或者说"在所有进程都几乎同时到达时, 采用SJF调度算法的平均等待时间、平均周转时间最少";
   - 如果不加上述前提条件, 则应该说"抢占式的短作业/进程优先调度算法(最短剩余时间优先, SRNT算法)的平均等待时间、平均周转时间最少"
3. 虽然严格来说, SJF的平均等待时间、平均周转时间并不一定最少, 但相比于其他算法(如 FCFS), SJF依然可以获得较少的平均等待时间、平均周转时间
4. 如果选择题中遇到"SJF 算法的平均等待时间、平均周转时间最少"的选项, 那最好判断其他选项是不是有很明显的错误, 如果没有更合适的选项, 那也应该选择该选项

![[Pasted image 20251007160926.png]]

## 高响应比优先(HRRN, Highest Response Ratio Next)

高响应比优先算法:
非抢占式的调度算法, 只有当前运行的进程主动放弃CPU时(正常/异常完成, 或主动阻塞), 才需要进行调度, 调度时计算所有就绪进程的响应比, 选响应比最高的进程上处理机.

![[Pasted image 20251007161623.png]]
![[Pasted image 20251007161651.png]]

## 时间片轮转(RR, Round-Robin)

时间片轮转调度算法: 轮流让就绪队列中的进程依次执行一个时间片(每次选择的都是排在就绪队列队头的进程).

![[Pasted image 20251007163015.png]]

## 优先级调度算法

非抢占式的优先级调度算法: 每次调度时选择当前已到达且优先级最高的进程. 当前进程主动放弃处理机时发生调度.

![[Pasted image 20251007172626.png]]

## 多级反馈队列调度算法

![[Pasted image 20251007173401.png]]

![[Pasted image 20251007173554.png]]

注: 比起早期的批处理操作系统来说, 由于计算机造价大幅降低,
因此之后出现的交互式操作系统(包括分时操作系统、实时操作系统等)更注重系统的响应时间、公平性、平衡性等指标.
而这几种算法恰好也能较好地满足交互式系统的需求.
因此这三种算法适合用于交互式系统. (比如UNIX使用的就是多级反馈队列调度算法).

## 多级队列调度算法

系统中按进程类型设置多个队列, 进程创建成功后插入某个队列.

- 队列之间可采取固定优先级, 或时间片划分
- 固定优先级: 高优先级空时低优先级进程才能被调度
- 时间片划分: 如三个队列分配时间50%、40%、10%

各队列可采用不同的调度策略, 如:

- 系统进程队列采用优先级调度
- 交互式队列采用RR
- 批处理队列采用FCFS

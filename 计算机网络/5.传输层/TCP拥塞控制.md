# TCP拥塞控制

## 拥塞控制的四种算法

- 慢开始算法
- 拥塞避免算法
- 快重传机制(冗余ACK) -> 快恢复算法

## TCP拥塞控制、TCP流量控制的区别与联系

![[Pasted image 20250830162303.png]]

- 流量控制: 控制端到端的数据发送量, 是**局部的**
- **拥塞控制**: 控制整个网络中每台主机的数据发送量, 降低路由器负载, 是**全局的**

如何判断网络拥塞?

- 发出的每个报文段, 都能顺利地收到ACK确认 -- 不拥塞
- 发出的报文段未能按时收到ACK, 引发**超时重传** -- 严重拥塞, 采用慢开始算法
- 收到**冗余ACK**, 引发快重传 -- 有点拥塞, cwnd缓慢下降

如果检测到网络拥塞怎么办?

- 迅速减少发送的数据量 -- 限制发送窗口
- 严重拥塞就迅速缩小拥塞窗口 -- 采用慢开始算法
- 有点拥塞就适当缩小拥塞窗口

### 拥塞控制考题特点

**发送窗口的上限值** = min[rwnd(接受窗口), cwnd(拥塞窗口)]

拥塞控制考题特点:

1. 常与"流量控制"综合考察, 此时需要考虑接收窗口大小
2. 通常只涉及单向传输(TCP连接双方只有一方发送数据)
3. _通常默认每个TCP报文段都以最大段长MSS满载数据_
4. _拥塞窗口的大小常以**MSS的倍数**作为单位_
5. 接收方收到一个报文段, 会"立即确认", 而不是"推迟确认"
   > 立即确认会导致冗余ACK, 快重传

注: 为了聚焦拥塞控制, 接下来的讨论中, 假设接收方的接收窗口足够大,这样发送窗口大小就只受拥塞窗口限制

## 慢开始、拥塞避免

![[Pasted image 20250830163029.png]]

- **慢开始算法**: cwnd 值从1开始, _每收到⼀个ACK, 就让 cwnd+1_ (当 `cwnd<ssthresh` 时适⽤)
  > 即每过一个RTT, cwnd数值翻倍(不能超过ssthresh), 大于等于ssthresh时采用拥塞避免算法, cwnd从ssthresh开始+1. <BR>
  > 若发生**超时重传**,说明网络严重拥塞, 则采用慢开始算法, 并设定新的ssthresh值(峰值cwnd的一半).
- **拥塞避免算法**: 在⼀个RTT内, _即使收到多个ACK, 也只能让 cwnd+1_ (当 `cwnd>=ssthresh` 时适⽤)

![[Pasted image 20250830170654.png]]

## 快重传、快恢复

![[截屏2025-08-30 17.09.45.png]]

- **快重传算法**: 当发送方收到三个确认号相同的冗余ACK时, ⽴即重传对应报⽂段
- **快恢复算法**: ⼀旦发生**快重传**, 就*将阈值、cwnd 都设为当前 cwnd 的⼀半*, 然后切换到为**拥塞避免算法**
  > 注意:ssthresh不能小于2

![[Pasted image 20250830171438.png]]


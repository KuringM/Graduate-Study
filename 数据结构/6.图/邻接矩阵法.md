# 图的存储 -- 邻接矩阵法

![[截屏2025-09-02 17.43.09.png]]

```c
#define MaxVertexNum 100 // 顶点数目的最大值
typedef struct {
  char Vex[MaxVertexNum]; // 顶点表 //顶点中可以存更复杂的信息
  int Edge[MaxVertexNum]
          [MaxVertexNum]; // 邻接矩阵, 边表, 还可以用 bool型或枚举型变量表示边
  int vexnum, arcnum;     // 图的当前顶点数和边数/弧数
} MGraph;
```

结点数为n的图$G = (V, E)$的邻接矩阵A是$n\times n$的. 将G的顶点编号为$v_1, v_2,\cdots, v_n$ , 则

$$
A[i][j]=
\begin{cases}
 1, & 若(v_i, v_j) 或 <v_i, v_j> 是 E(G)中的边\\
 0, & 若(v_i, v_j) 或 <v_i, v_j> 不是 E(G)中的边\\
\end{cases}
$$

- 无向图第i个结点的度 = 第i行(或第i列)的非零元素个数
- 有向图第i个结点的出度 = 第i行的非零元素个数
- 有向图第i个结点的入度 = 第i列的非零元素个数
- 有向图第i个结点的度 = 第i行、第i列的非零元素个数之和
- 邻接矩阵法求顶点的度/出度/入度的时间复杂度为 $O(|V|)$

## 邻接矩阵法存储带权图(网)

![[截屏2025-09-02 20.20.10.png]]

- 没有边的可以用"无穷"表示
- 指向自己的可以用0表示

```c
#define MaxVertexNum 100     // 顶点数目的最大值
#define INFINITY 最大的int值 // 宏定义常量"无穷", 可用int的上限值表示"无穷"
typedef char VertexType;     // 顶点的数据类型
typedef int EdgeType;        // 带权图中边上权值的数据类型
typedef struct {
  VertexType Vex[MaxVertexNum];              // 顶点
  EdgeType Edge[MaxVertexNum][MaxVertexNum]; // 边的权
  int vexnum, arcnum;                        // 图的当前顶点数和弧数
} MGraph;
```

## 邻接矩阵法的性能分析

- 空间复杂度: $O(|V|^2)$ -- 只和顶点数相关, 和实际的边数无关
- 适合用于存储**稠密图** (边很多)
- 无向图的邻接矩阵是对称矩阵, 可以压缩存储(只存储上三角区/下三角区)

## 邻接矩阵法的性质

设图G的邻接矩阵为A(矩阵元素为0/1), 则$A^{n}$的元素$A^n[i][j]$等于由顶点i到顶点j的长度为n的路径的数目

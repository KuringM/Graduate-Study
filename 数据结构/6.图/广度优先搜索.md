# 广度优先搜索

树的广度优先遍历(层序遍历):

> 不存在"回路", 搜索相邻的结点时, 不可能搜到已经访问过的结点

1. 若树非空, 则根节点入队
2. 若队列非空, 队头元素出队并访问, 同时将该元素的孩子依次入队
3. 重复2直到队列为空

图搜索相邻的顶点时, 有可能搜到已经访问过的顶点

广度优先遍历(Breadth-First-Search, **BFS**)要点:

1. 找到与一个顶点相邻的所有顶点
   - `FirstNeighbor(G,x)`: 求图G中顶点x的第一个邻接点, 若有则返回顶点号. 若x没有邻接点或图中不存在x, 则返回-1.
   - `NextNeighbor(G,x,y)`: 假设图G中顶点y是顶点x的一个邻接点, 返回除y之外顶点x的下一个邻接点的顶点号, 若y是x的最后一个邻接点, 则返回-1.
2. 标记哪些顶点被访问过
3. 需要一个辅助队列(存储遍历序列)

## 代码实现

```c
bool visited[MAX_VERTEX_NUM];    // 访问标记数组 //初始都为false
void BFSTraverse(Graph G) {      // 对图G进行广度先遍历
  for (i = 0; i < G.vexnum; ++i) // 访问标记数组初始化
    visited[i] = FALSE;
  InitQucue(Q);                  // 初始化辅助队列Q
  for (i = 0; i < G.vexnum; ++i) // 从0号顶点开始遍历
    if (!visited[i])             // 对每个连通分量调用一次 BFS()
      BFS(G, i);                 // 若v_i未访问过, 从v_i开始调用 BES()
}

// 广度优先遍历
void BFS(Graph G, int v) { // 从顶点V出发, 广度优先遍历图G
  visit(v);                // 访问初始顶点v
  visited[v] = TRUE;       // 对v做已访问标记
  Enqueue(Q, v);           // 顶点v入队列Q
  while (!isEmpty(Q)) {
    DeQueue(Q, v); // 顶点v出队列
    for (w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))
      // 检测v所有邻接点
      if (!visited[w]) {   // w为v的尚未访问的邻接顶点
        visit(w);          // 访问顶点w
        visited[w] = TRUE; // 对w做已访问标记
        EnQueue(Q, w);     // 顶点w入队列
      } // if
  } // while
}
```

## 复杂度分析

- 对于==无向图, 调用BFS函数的次数=连通分量数==.
- 空间复杂度: 最坏情况, 辅助队列大小为 $O(|V|)$.
- 邻接矩阵存储的图:
  - 访问 $|V|$ 个顶点需要$O(|V|)$的时间,
  - 查找每个顶点的邻接点都需要$O(|V|)$的时间, 而总共有$|V|$个顶点,
  - ==时间复杂度=$O(|V|^2)$==.
- 邻接表存储的图:
  - 访问 $|V|$ 个顶点需要$O(|V|)$的时间,
  - 查找各个顶点的邻接点共需要$O(|E|)$的时间,
  - 时间复杂度==$O(|V|+|E|)$==.

## 广度度优先遍历序列

- 邻接矩阵产生的遍历序列唯一
- 邻接表产生的遍历序列不唯一

## 广度优先生成树、 广度优先生成森林

- 广度优先生成树由广度优先遍历过程确定.
- 由于邻接表的表示方式不唯一, 因此基于邻接表的广度优先生成树也不唯一.
- 对非连通图的广度优先遍历, 可得到广度优先生成森林

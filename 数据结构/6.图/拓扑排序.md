# 拓扑排序

**AOV网**(Activity On Vertex NetWork, 用顶点表示活动的网):

- 用**DAG图**(有向无环图)表示一个工程.
- 顶点表示活动, 有向边$<V_i, V_j>$表示活动$V_i$必须先于活动$V_j$进行.

## 定义

拓扑排序:
在图论中, 由一个有向无环图的顶点组成的序列, 当且仅当满足下列条件时, 称为该图的一个拓扑排序:

1. 每个顶点出现且只出现一次.
2. 若顶点A在序列中排在顶点B的前面, 则在图中不存在从顶点B到顶点A的路径.

或定义为:
拓扑排序是对有向无环图的顶点的一种排序,
它使得若存在一条从顶点A到顶点B的路径,
则在排序中顶点B出现在顶点A的后面.
==每个AOV网都有一个或多个拓扑排序序列==.

> 拓扑排序: 找到做事的先后顺序

拓扑排序的实现:

1. 从AOV网中选择一个没有前驱的顶点并输出.
2. 从网中删除该顶点和所有以它为起点的有向边.
3. 重复1和2直到当前的==AOV网为空==或==当前网中不存在无前驱的顶点为止(说明有回路)==.

## 代码实现

```c
#define MaxVertexNum 100   // 图中顶点数目的最大值
typedef struct ArcNode {   // 边表结点
  int adjvex;              // 该弧所指向的顶点的位置
  struct ArcNode *nextarc; // 指向下一条弧的指针
  // InfoType info;// 网的边权值
} ArcNode;

typedef struct VNode { // 顶点表结点
  VertexType data;     // 顶点信息
  ArcNode *firstarc;   // 指向第一条依附该顶点的弧的指针
} VNode, AdjList[MaxVertexNum];

typedef struct {      // 邻接表
  AdjList vertices;   // 图的顶点数和弧数
  int vexnum, arcnum; // Graph是以邻接表存储的图类型
} Graph;

int indegree[MaxVertexNum]; // 当前顶点入度
int print[MaxVertexNum];    // 记录拓扑序列

bool TopologicalSort(Graph G) {
  InitStack(S); // 初始化栈, 存储入度为0的顶点 (也可以用队列)
  for (int i = 0; i < G.vexnum; i++)
    if (indegree[i] == 0)
      Push(S, 1); // 将所有入度为0的顶点进栈

  int count = 0;        // 计数, 记录当前已经输出的顶点数
  while (!IsEmpty(S)) { // 栈不空, 则存在入度为0的顶点
    Pop(S, 1);          // 栈顶元素出栈
    print[count++] = i; // 输出顶点立
    for (p = G.vertices[i].firstarc; p; p = p -›nextarc) {
      // 将所有i指向的顶点的入度减1, 并且将入度减为0的顶点压入栈S
      v = p->adjvex;
      if (!(--indegree[v]))
        Push(S, v); // 入度为0, 则入栈
    }
  } // while

  if (count < G.vexnum)
    return false; // 排序失败, 有向图中有回路
  else
    return true; // 拓扑排序成功
}
```

时间复杂度: $O(|V|+|E|)$, 若采用邻接矩阵, 则需$O(|V|^2)$.

## 逆拓扑排序

对一个AOV网, 如果采用下列步骤进行排序, 则称之为**逆拓扑排序**:

1. 从AOV网中选择一个没有后继(**出度为0**)的顶点并输出.
2. 从网中删除该顶点和所有以它为终点的有向边.
3. 重复1和2直到当前的AOV网为空.

### 逆拓扑排序的代码实现

- 练习: 模仿拓扑排序的思想实现逆拓扑排序
- 思考: 使用不同的存储结构来对时间复杂度的影响

### 逆拓扑排序的代码实现(DFS算法)

```c
void DFSTraverse(Graph G) { // 对图G进行深度优先遍历
  for (v = 0; v < G.vexnum; ++v)
    visited[v] = FALSE;          // 初始化已访问标记数据
  for (v = 0; v < G.vexnum; ++v) // 本代码中是从v=0开始遍历
    if (!visited[v])
      DFS(G, V);
}

void DFS(Graph G, int v) { // 从顶点v出发, 深度优先遍历图G
  visited[v] = TRUE;       // 设已访问标记
  for (w = FirstNeighbor(G, v); w >= 0; w = NextNeighor(G, v, w))
    if (!visited[w]) { // w为u的尚未访问的邻接顶点
      DFS(G, w);
    } // if

  print(v); // 输出顶点
}
```

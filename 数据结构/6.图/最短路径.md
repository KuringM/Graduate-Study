# 最短路径

## 单源最短路径

### BFS算法(无权图)

> 注: 无权图可以视为一种特殊的带权图, 只是每条边的权值都为1.

就是对BFS的小修改, 在visit一个顶点时, 修改其最短路径⻓度 `d[]` 并在 `path[]` 记录前驱结点.

```c
// 求顶点 U 到其他顶点的最短路径
void BFS_MIN_Distance(Graph G, int u) {
  // d[i]表示从u到i结点的最短路径
  for (i = 0; i < G.vexnum; ++i) {
    d[i] =∞;      // 初始化路径长度
    path[i] = -1; // 最短路径从哪个顶点过来
  }
  d[u] = 0;
  visited[u] = TRUE;
  EnQueue(Q, u);
  while (!isEmpty(Q)) { // BFS算法主过程
    DeQueue(Q, u);      // 队头元素u出队
    for (w = FirstNeighbor(G, u); w >= 0; w = NextNeighbor(G, u, w))
      if (!visited[w]) {   // w为u的尚未访问的邻接顶点
        d[w] = d[u] + 1;   // 路径长度加1
        path[w] = u;       // 最短路径应从u到w
        visited[w] = TRUE; // 设已访问标记
        EnQueue(Q, w);     // 顶点w入队
      } // if
  } // while
}
```

### Dijkstra算法(带权图、无权图)

- BFS算法求单源最短路径只适用于无权图, 或所有边的权值都相同的图.
- 带权路径⻓度 -- 当图是带权图时, 一条路径上所有边的权值之和, 称为该路径的带权路径⻓度

构造三个辅助数组:

- `final[]`: 标记各顶点是否已找到最短路径, 即是否归入集合S;
- `dist[]`: 记录从源点$v_0$到其他各顶点当前的最短路径长度;
  - 它的初始值为: 若从的$v_0$到$v_i$有弧, 则`dist[i]`为弧上的权值: 否则置`dist[i]`为$\infty$.
- `path[]`: `path[i]`表示从源点到顶点$i$之间的最短路径的前驱结点.

#### 处理过程

初始:

- 若从V0开始, 令 `final[0]=ture; dist[0]=0; path[0]=-1`.
- 其余顶点 `final[k]=false; dist[k]=arcs[0][k]; path[k]= (arcs[0][k]==∞) ? -1 : 0`
  > 注: `arcs[i][j]`表示$V_i$到$V_j$的弧的权值)

n-1轮处理:

- 循环遍历所有顶点, 找到还没确定最短路径, 且dist最小的顶点$V_i$, 令`final[i]=ture`.
- 并检查所有邻接自$V_i$的顶点, 对于邻接自$V_i$的顶点$V_j$,
- 若 `final[j]==false && dist[i]+arcs[i][j] < dist[j]`, 则令 `dist[j]=dist[i]+arcs[i][j]; path[j]=i`.

时间复杂度:$O(n^2)$即$O(|V|^2)$

Dijkstra算法不适用于有负权值的带权图.

## 各顶点间的最短路径

### Floyd 算法(带权图、无权图)

Floyd算法: 求出每一对顶点之间的最短路径.

- 使用动态规划思想, 将问题的求解分为多个阶段.
- 对于n个顶点的图G, 求任意一对顶点 $V_i \to V_j$ 之间的最短路径可分为如下几个阶段:
  - 初始: 不允许在其他顶点中转, 最短路径是?
  - 0: 若允许在 V0 中转, 最短路径是? -- 求 $A^{(0)}$ 和 $path^{(0)}$
  - 1: 若允许在 V0、V1 中转, 最短路径是? -- 求 $A^{(1)}$ 和 $path^{(1)}$
  - 2: 若允许在 V0、V1、V2 中转, 最短路径是?
  - ...
  - n-1: 若允许在 V0、V1、V2 ... Vn-1 中转, 最短路径是?

算法描述:

定义一个n阶方阵序列 $A^{(-1)}, A^{(0)}, \cdots, A^{(n-1)}$.

- $A^{(-1)}[i][j]= arcs[i][j]$,
- $A^{(k)} = \text{Min}\{A^{(k-1)}[i][j],\quad A^{(k-1)}[i][k] + A^{(k-1)}[k][j]\}, k= 0, 1, \cdots, n-1$.
- $A^{(0)}[i][j]$是从顶点 $v_i$到 $v_j$、中间顶点是 $v_0$的最短路径的长度,
- $A^{(k)}[i][j]$是从顶点 $v_i$到 $v_j$、中间顶点的序号不大于$k$的最短路径的长度.

![[Pasted image 20250903115419.png]]

```c
for (int k = 0, k < n, k++) {   // 考虑Vk作为中转点
  for (int i = 0; i < n; i++) { // 遍历整个矩阵, i为行号, j为列号
    for (int j = 0; j < n; i++) {
      if (A[i][j] > A[i][k] + A[k][j]) { // 以 Vk 为中转点的路径更短
        A[i][j] = A[i][k] + A[k][j];     // 更新最短路径长度
        path[i][j] = k;                  // 中转点
      }
    }
  }
}
```

- 时间复杂度, $O(|V|^3)$
- 空间复杂度, $O(|V|^2)$
- Floyd算法可以用于负权值带权图
- Floyd 算法不能解决带有"负权回路"的图(有负权值的边组成回路), 这种图有可能没有最短路径

## 总结

![[Pasted image 20250903115548.png]]

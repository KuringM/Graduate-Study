# 深度优先搜索

树的深度优先遍历

![[树和森林的遍历#先根遍历]]

## 代码实现

```c
bool visited[MAX_VERTEX_NUM];    // 访问标记数组 //初始都为false
void DFSTraverse(Graph G) {      // 对图G进行深度先遍历
  for (v = 0; v < G.vexnum; ++i) // 访问标记数组初始化
    visited[v] = FALSE;
  InitQucue(Q);                  // 初始化辅助队列Q
  for (v = 0; v < G.vexnum; ++v) // 从0号顶点开始遍历
    if (!visited[v])
      DFS(G, v);
}

void DFS(Graph G, int v) { // 从顶点V出发, 深度度优先遍历图G
  visit(v);                // 访问初始顶点v
  visited[v] = TRUE;       // 对v做已访问标记
  for (w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))
    // 检测v所有邻接点
    if (!visited[w]) { // w为v的尚未访问的邻接顶点
      DFS(G, w);
    } // if
}
```

## 复杂度分析

空间复杂度: 来自函数调用栈.

- 最坏情况, 递归深度为$O(|V|)$,
- 最好情况, 递归深度为$O(1)$.

时间复杂度: 访问各结点所需时间+探索各条边所需时间

- 邻接矩阵存储的图:
  - 访问 $|V|$ 个顶点需要$O(|V|)$的时间
  - 查找每个顶点的邻接点都需要$O(|V|)$的时间, 而总共有$|V|$个顶点
  - 时间复杂度= $O(|V|^2)$
- 邻接表存储的图:
  - 访问 $|V|$ 个顶点需要$O(|V|)$的时间
  - 查找各个顶点的邻接点共需要$O(|E|)$的时间,
  - 时间复杂度= $O(|V|+|E|)$

## 深度优先遍历序列

- 同一个图的邻接矩阵表示方式唯一, 因此深度优先遍历序列唯一
- 同一个图邻接表表示方式不唯一, 因此深度优先遍历序列不唯一

## 深度优先生成树、深度优先生成森林

- 同一个图的邻接矩阵表示方式唯一, 因此深度优先遍历序列唯一, 深度优先生成树也唯一
- 同一个图邻接表表示方式不唯一, 因此深度优先遍历序列不唯一, 深度优先生成树也不唯一

# 希尔排序

思想: 先追求表中元素部分有序, 再逐渐逼近全局有序.

希尔排序(Shell Sort):

- 先将待排序表分割成若干形如 $L[i, i + d, i + 2d, \cdots, i + kd]$ 的"特殊"子表,对各个子表分别进行直接插入排序.
- 缩小增量d, 重复上述过程, 直到d=1为止.

![[Pasted image 20250905150519.png]]

## 算法实现

```c
// 希尔排序
void ShellSort(int A[], int n) {
  int d, i, j; // A[0]只是暂存单元, 不是哨兵, 当j<=0时, 插入位置已到
  for (d = n / 2; d >= 1; d = d / 2) // 步长变化
    for (i = d + 1; i <= n; ++i)
      if (A[i] < A[i - d]) { // 需将A[i]插入有序增量子表
        A[0] = A[i];         // 暂存在A[0]
        for (j = i - d; j > 0 && A[0] < A[j];
             j -= d)       // 记录后移, 查找插入的位置 A[j + d] = A[0];
          A[j + d] = A[j]; // 插入
      } // if
}
```

## 算法性能分析

空间复杂度: $O(1)$

时间复杂度和增量序列 $d_1, d_2, d_3...$ 的选择有关, 目前无法用数学手段证明确切的时间复杂度

- 最坏时间复杂度为 $O(n^2)$, 当n在某个范围内时, 可达 $O(n^{1.3})$

稳定性: 不稳定!

适用性: 仅适用于顺序表, 不适用于链表.

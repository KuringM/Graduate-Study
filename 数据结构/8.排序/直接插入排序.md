# 直接插入排序

插入排序 -- 算法思想: 每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中,直到全部记录插入完成.

顺序查找找到插入的位置, 适用于顺序表、链表.

```c
// 直接插入排序 -- A[0]-A[n]-> data
void InsertSort(int A[], int n) {
  int i, j, temp;
  for (i = 1; i < n; i++)  // 将各元素插入已排好序的序列中
    if (A[i] < A[i - 1]) { // 若A[i]关键字小于前驱
      temp = A[i];         // 用temp暂存A[i]
      for (j = i - 1; j >= 0 && A[j] > temp; --j) // 检查所有前面已排好序的元素
        A[j + 1] = A[j]; // 所有大于temp的元素都向后挪位
      A[j + 1] = temp;   // 复制到插入位置
    }
}

// 直接插入排序(带哨兵) -- A[0]->哨兵, A[1]-A[n]-> data
void InsertSort(int All, int n) {
  int i, j;
  for (i = 2; i <= n; i++) // 依次将A[2]~A[n]插入到前面已排序序列
    if (A[i] < A[i - 1]) { // 若A[i]关键码小于其前驱, 将A[i]插入有序表
      A[0] = A[i];         // 复制为哨兵, A[0]初始不存放元素
      for (j = i - 1; A[0] < A[j]; --j) // 从后往前查找待插入位置
        A[j + 1] = A[j];                // 向后挪位
      A[j + 1] = A[0];                  // 复制到插入位置
    }
} // 优点: 不用每轮循环都判断 j>=0
```

- 空间复杂度: O(1)
- 时间复杂度: 主要来自对比关键字、移动元素.
  - 若有 n 个元素, 则需要 n-1 趟处理
  - 最好情况: 共n-1趟处理, 每一趟只需要对比关键字1次, 不用移动元素.
    最好时间复杂度 -- $O(n)$
  - 最坏情况:
    - 第1趟: 对比关键字2次, 移动元素3次
    - 第2趟: 对比关键字3次, 移动元素4次
    - 第 i 趟: 对比关键字 i+1次, 移动元素 i+2 次
    - ...
    - 第n-1趟: 对比关键字 n 次, 移动元素 n+1 次
    - 最坏时间复杂度--$O(n^2)$
  - 平均时间复杂度: $O(n^2)$
- 算法稳定性: 稳定

## 对链表进行插入排序

- TODO: Code <2025/09/05, Kuring> -

移动元素的次数变少了, 但是关键字对比的次数依然是$O(n^2)$ 数量级, 整体来看时间复杂度依然是$O(n^2)$.

# 冒泡排序

基于"交换"的排序: 根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置.

从后往前(或从前往后)两两比较相邻元素的值, 若为逆序(即`A[i-1]>A[i]`), 则交换它们, 直到序列比较完.
称这样过程为"一趟"冒泡排序. 最多只需 n-1 趟排序.

- 第一趟排序使关键字值最小的一个元素"冒"到最前面;
- 第2趟结束后, 最小的两个元素会"冒"到最前边;
- 第3趟结束后, 最小的3个元素会"冒"到最前边; ...
- 每一趟排序都可以使一个元素的移动到最终位置, 已经确定最终位置的元素在之后的处理中无需再对比;
- 若某一趟排序没有发生"交换", 说明此时已经整体有序.

```c
// 交换 //每次交换都需要移动元素3次
void swap(int &a, int &b) {
  int temp = a;
  a = b;
  b = temp;
}

// 冒泡排序
void BubbleSort(int A[], int n) {
  for (int i = 0; i < n - 1; i++) {
    bool flag = false;              // 表示本趟冒泡是否发生交换的标志
                                    // i 所指位置之前的元素都已"有序"
    for (int j = n - 1; j > i; j--) // 一趟冒泡过程
      // 只有A[j-1] > A[j]时才交换, 因此算法是稳定的
      if (A[j - 1] > A[j]) { // 若为逆序
        swap(A[j - 1], A[j]);
        flag = true;
      }
    if (flag == false)
      return; // 本趟遍历后没有发生交换, 说明表已经有序
  }
}
```

## 算法性能分析

空间复杂度: O(1)

最好情况(有序): `1 2 3 4 5 6 7 8`

- 比较次数=n-1; 交换次数=0
- 最好时间复杂度=$O(n)$

最坏情况(逆序): `8 7 6 5 4 3 2 1`

- 比较次数$= (n-1) + (n-2) + \cdots +1 = \frac{n(n-1)}{2}=$交换次数
- 每次交换都需要移动元素3次 `swap()`, 移动次数= $\sum\limits_{i=1}^{n-1}3(n-1)= \frac{3(n(n-1))}{2}$
- 最坏时间复杂度=$O(n^2)$

平均时间复杂度=$O(n^2)$

稳定性: 稳定.

适用性: 顺序表, 链表.

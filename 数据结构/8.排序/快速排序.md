# 快速排序

算法思想:

- 在待排序表`L[1...n]`中任取一个元素`pivot`作为枢轴(或基准, 通常取首元素),
- 通过一趟排序将待排序表划分为独立的两部分`L[1...k-1]`和`L[k+1...n]`, 使得
  - `L[1...k-1]`中的所有元素小于`pivot`,
  - `L[k+1...n]`中的所有元素大于等于`pivot`,
- 则`pivot`放在了其最终位置`L(k)`上, 这个过程称为一次**划分**.
- 然后分别递归地对两个子表重复上述过程, 直至每部分内只有一个元素或空为止, 即所有元素放在了其最终位置上.
  > 用第一个元素把待排序序列**划分**为两个部分. 左边更小, 右边更大. 该元素的最终位置已确定.

注: 408原题中说, 对所有尚未确定最终位置的所有元素进行一遍处理称为"一趟"排序, 因此一次"划分"≠一趟排序.
一次划分可以确定一个元素的最终位置, 而一趟排序也许可以确定多个元素的最终位置.

![[截屏2025-09-05 17.18.25.png]]

## 代码实现

```c
// 用第一个元素将待排序序列划分成左右两个部分
int Partition(int A[], int low, int high) {
  int pivot = A[low];  // 第一个元素作为枢轴
  while (low < high) { // 用low、high搜索枢轴的最终位置
    while (low < high && A[high] >= pivot)
      --high;
    A[low] = A[high]; // 比枢轴小的元素移动到左端
    while (low < high && A[low] <= pivot)
      ++low;
    A[high] = A[low]; // 比枢轴大的元素移动到右端
  }
  A[low] = pivot; // 枢轴元素存放到最终位置
  return low;     // 返回存放枢轴的最终位置
}

// 快速排序
void QuickSort(int A[], int low, int high) {
  if (low < high) {                         // 递归跳出的条件
    int pivotpos = Partition(A, low, high); // 划分
    QuickSort(A, low, pivotpos - 1);        // 划分左子表
    QuickSort(A, pivotpos + 1, high);       // 划分右子表
  }
}
```

## 算法效率分析

每一层的QuickSort只需要处理剩余的待排序元素, 时间复杂度不超过$O(n)$.

- 把n个元素组织成二叉树, 二叉树的层数就是递归调用的层数.
- n个结点的二叉树最小高度 =$\lfloor \log_2 n \rfloor + 1$, 最大高度 = n

算法表现主要取决于递归深度, 若每次"划分"越均匀, 则递归深度越低. <BR>
"划分"越不均匀, 递归深度越深.

时间复杂度=$O(n \times 递归层数)$

- 最好时间复杂度=$O(n\log_2 n)$
  - 比较好的情况
    - 若每一次选中的**枢轴**将待排序序列划分为均匀的两个部分, 则递归深度最小, 算法效率最高
- 最坏时间复杂度=$O(n^2)$
  - 最坏的情况
    - 若每一次选中的**枢轴**将待排序序列划分为很不均匀的两个部分, 则会导致递归深度增加, 算法效率变低
    - 若初始序列有序或逆序, 则快速排序的性能最差(因为每次选择的都是最靠边的元素)
      > (可优化, 尽量选择可以把数据中分的枢轴元素. )
- 平均时间复杂度=$O(n\log_2 n)$
  - 快速排序是所有内部排序算法中平均性能最优的排序算法

空间复杂度=$O(n \times 递归层数)$

- 最好空间复杂度=$O(\log_2 n)$
- 最坏空间复杂度=$O(n)$

快速排序算法优化思路:
尽量选择可以把数据中分的枢轴元素.
eg:

1. 选头、中、尾三个位置的元素, 取中间值作为枢轴元素;
2. 随机选一个元素作为枢轴元素

稳定性: 不稳定!

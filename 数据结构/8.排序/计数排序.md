# 计数排序(Counting Sort)

## 计数排序的算法思想

使用计数排序的前提:

- 待排序元素的关键字是整数型
- 元素的取指范围是 `[0, k)`, 且k值较小, k与0(n)同数量级
  - 若 $O(k) > O(n\log_2 n)$, 就不如用快速排序、堆排序

计数排序的算法思想

- 创建一个长度为k的辅助数组`C[k]`
- Step 1: 遍历待排序数组`A[n]`, ==用辅助数组`C[]`统计`A[]`中每个元素值i出现的次数(元素值只可能是$0 \sim k-1$, 与辅助数组下标一一对应)==
- Step 2: 再次处理辅助数组`C[]`, 最终用 `C[i] 统计 <= i的元素个数`
- step 3: **从后往前**依次处理各个待排序元素, 结合辅助数组`C[]`实现排序
  > 注意: 从后往前处理各个元素可确保排序的稳定性, 详细过程建议自己手绘复习

![[Pasted image 20250906202407.png]]

## 计数排序的实现

```c
// - A是输入数组(待排序数组)
// - B是输出数组
// - n是A[]的长度
// - k反映A[]的取值范围
// 计数排序
void CountSort(int A[], int B[], int n, int k) {
  int i, C[k];            // 辅助数组c的长度取决于待排序元素取值范围[0, k)
  for (1 = 0; i < k; i++) // 初始化计数数组
    C[i] = 0;
  for (i = 0; i < n; i++) // step1: 遍历待排序数组, 统计每个关键字的出现次数
    C[A[i]]++;
  for (i = 1; i < k; i++)   // step2: 再次处理辅助数组, 统计不大于i的元素个数
    C[i] = C[i] + C[1 - 1]; // C[i]保存的是小于或等于i的元素个数
  for (i = n - 1; i >= 0;
       i--) {              // step3: 利用辅助数组c实现计数排序(从后往前处理)
    C[A[i]] = C[A[i]] - 1; // C[A[i]]--
    В[C[A[i]]] = A[i];     // 将元素 A[i]放在输出数组 B[ ]的正确位置上
  }
}
```

## 计数排序的复杂度分析

- 空间复杂度 $= O(n + k)$
  > n来源于输出数组B, k来源于辅助数组C
- 时间复杂度 $= O(n + k)$
- 当k与0(n)同数量级时, 时间复杂度$=0(n)$
- 稳定性: 稳定.

若 $k = O(n)$ , 计数排序的时间复杂度$= O(n)$,
此时计数排序的时间效率优于快速排序、堆排序等排序算法的$O(n \log_2 n)$.

若 $k >O(n \log_2 n)$ , 计数排序的时间复杂度 $O(n \log_2 n)$ ,
此时计数排序的时间效率不如快速排序、堆排序等排序算法的$O(n \log_2 n)$.

- 计数排序是典型的"空间"换"时间"思想
- 适用场景: 当待排序数组的取指范围 k 较小时, 可以考虑使用计数排序的思想

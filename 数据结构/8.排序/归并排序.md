# 归并排序 (Merge Sort)

## 什么是 Merge(归并/合并)?

- 归并: 把两个或多个已经有序的序列合并成一个
- "2路"归并--每选出一个小元素注需对比关键字1次
- m路归并, 每选出一个元素需要对比关键字 m-1 次

## 归并排序(手算模拟)

在内部排序中一般采用2路归并,
核心操作: 把数组内的两个有序序列归并为一个.

![[Pasted image 20250906192428.png]]

## 代码实现

```c
int *B = (int *)malloc(n * sizeof(int)); // 辅助数组B, 大小与A相同

// A[Low...mid] 和A[mid + 1...high] 各自有序,将两个部分归并
void Merge(int All, int low, int mid, int high) {
  int i, j, k;
  for (k = low; k <= high; k++)
    B[k] = A[k]; // 将A中所有元素复制到B中
  for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++) {
    if (B[i] <= B[j]) // 两个元素相等时, 优先使用靠前的那个(稳定性)
      A[k] = B[i++];  // 将较小值复制到A中; <==> A[k]=B[i]; i++;
    else
      A[k] = B[j++];
  } // for
  while (i <= mid) // 没有归并完的部分复制到尾部
    A[k++] = B[i++];
  while (j <= high)
    A[k++] = B[j++];
}

void MergeSort(int All, int low, int high) {
  if (low < high) {
    int mid = (low + high) / 2;  // 从中间划分
    MergeSort(A, low, mid);      // 对左半部分归并排序
    MergeSort(A, mid + 1, high); // 对右半部分归并排序
    Merge(A, low, mid, high);    // 归并
  } // if
}
```

## 算法效率分析

- 时间复杂度为$O(n\log_2 n)$
  - 2路归并的"归并树"--形态上就是一棵倒立的二叉树
  - 二叉树的第h层最多有 $2^{h-1}$ 个结点
  - 若树高为h, 则应满足 $n \leqslant  2^{h-1}$ 即 $h− 1 = \lceil \log_2 n \rceil$
  - 结论: n个元素进行2路归并排序, 归并趟数= $\lceil \log_2 n \rceil$
  - 每趟归并时间复杂度为 $O(n)$
- 空间复杂度 $=O(n)$ , 来自于辅助数组B
- 稳定性: 稳定的

# 堆排序

选择排序: 每一趟在待排序元素中选取关键字最小(或最大)的元素加入有序子序列.

## 什么是"堆(Heap)"?

若n个关键字序列 `L[1...n]` 满足下面某一条性质, 则称为堆(Heap):

1. 若满足: $L(i)\geqslant L(2i)且L(i)\geqslant L(2i+1) (1 \leqslant  i \leqslant \frac{n}{2} )$ -- 大根堆(大顶堆)
2. 若满足: $L(i)\leqslant L(2i)且L(i)\leqslant L(2i+1) (1 \leqslant  i \leqslant \frac{n}{2} )$ -- 小根堆(小顶堆)

- 大根堆: 完全二叉树中, `根 >= 左、右`
- 小根堆: 完全二叉树中, `根 <= 左、右`

> 顺序存储的完全二叉树的特点:
>
> - i 的左孩子 -- 2i
> - i 的右孩子 -- 2i+1
> - i 的父节点 -- $\lfloor i/2 \rfloor$
> - i 所在的层次 -- $\lceil \log_2(n+1) \rceil或\lfloor \log_2 n \rfloor+ 1$

## 基于大根堆的建堆、排序

### 大根堆建立

思路: 把所有非终端结点都检查一遍, 是否满足大根堆的要求, 如果不满足, 则进行调整.

- 检查当前结点是否满足 `根 >= 左、右`:
  - ==若不满足, 将当前结点与更大的一个孩子互换==.
  - 若元素互换破坏了下一级的堆, 则采用相同的方法继续往下调整(==小元素不断"下坠"== )

#### 建立大根堆的代码实现

```c
// 建立大根堆
void BuildMaxHeap(int A[], int len) {
  for (int i = len / 2; i > 0;
       i--) // 从后往前调整所有非终端结点
            // i = len /2 是从最底层的分支结点开始调整, 比 i 大的都是叶子结点
    HeadAdjust(A, i, len);
}

// 将以 K 为根的子树调整为大根堆
void HeadAdjust(int A[], int k, int len) {
  A[0] = A[k];                            // A[0]暂存子树的根结点 -- "哨兵"
  for (int i = 2 * k; i <= len; i *= 2) { // 沿key较大的子结点向下筛选
    if (i < len && A[i] < A[i + 1])
      i++;            // 取key较大的子结点的下标
    if (A[0] >= A[i]) // 筛选结束
      break;
    else {
      A[k] = A[i]; // 将A[1]调整到双亲结点上
      k = i;       // 修改k值, 以便继续向下筛选
    }
  }
  A[K] = A[0]; // 被筛选结点的值放入最终位置
}
```

### 大根堆排序

堆排序:

- 每一趟将堆顶元素加入有序子序列(与待排序序列中的最后一个元素交换).
- 并将**待排序元素序列**再次调整为大根堆(小元素不断"下坠").
  > 注意: 基于"大根堆"的堆排序得到"递增序列" <BR>
  > 注意: 基于"小根堆"的堆排序得到"递减序列"

#### 基于大根堆进行排序(Code)

```c
// 建立大根堆
void BuildMaxHeap(int A[], int len);

// 将以 K 为根的子树调整为大根堆
void HeadAdjust(int A[], int k, int len);

// 堆排序的完整逻辑
void HeapSort(int A[], int len) {
  BuildMaxHeap(A, len); // 初始建堆
  // i = len: 指向待排序元素序列中的最后一个(堆底元素)
  for (int i = len; i > 1; i--) { // n-1趟的交换和建堆过程
    swap(A[i], A[1]);             // 堆顶元素和堆底元素交换
    HeadAdjust(A, 1, i - 1);      // 把剩余的待排序元素整理成堆
  }
```

### 算法效率分析

==建堆的过程, 关键字对比次数不超过 4n, 建堆时间复杂度 $= O(n)$==.

###### Proof

- 一个结点, 每"下坠"一层, 最多只需对比关键字2次.
- 若树高为h, 某结点在第 i 层, 则将这个结点向下调整最多只需要"下坠" h-i 层, 关键字对比次数不超过 2(h-i)
  > n个结点的完全二叉树树高 $h=\lfloor \log_2 n \rfloor + 1$
- 第 i 层最多有 $2^{i-1}$ 个结点, 而只有第 1 ~ (h-1) 层的结点才有可能需要"下坠"调整

将整棵树调整为大根堆, **关键字对比次数**不超过

$$
\sum\limits_{i=h-1}^{1} 2^{i-1} 2(h-i) =
\sum\limits_{i=h-1}^{1} 2^{i} (h-i) =
\sum\limits_{j=1}^{h-1} 2^{h-j}j \leqslant
2n \sum\limits_{j=1}^{h-1}\frac{j}{2^j} (差比数列求和(错位相减法))\leqslant 4n
$$

---

- 堆排序总共需要n-1趟, 每一趟交换后都需要将根节点"下坠"调整
- 根节点最多"下坠" h-1 层,
- 而每"下坠"一层, 最多只需对比关键字2次(时间复杂度: $O(1)$), 因此每一趟排序复杂度不超过 $O(h) = O(\log_2 n)$
- 共 n-1 趟, 总的时间复杂度 $= O(n\log_2 n)$

---

- ==堆排序的时间复杂度 $= O(n) + O(n\log)2 n) = O(n\log_2 n)$==
- ==堆排序的空间复杂度 $= O(1)$==
- 稳定性: 不稳定!

## 基于"小根堆"如何建堆、排序?

- TODO: Nomething <2025/09/06, Kuring> -

## 堆的插入删除

### 在堆中插入新元素

对于小根堆, ==新元素放到表尾== , 与父节点对比,

- 若新元素比父节点更小, 则将二者互换. 新元素就这样一路"上升", 直到无法继续上升为止
- 每次"上升"调整只需对比关键字1次

### 在堆中删除元素

==被删除的元素用堆底元素替代== , 然后让该元素不断"下坠", 直到无法下坠为止

- 下方有两个孩子, 则"下坠"一层, 需**对比关键字** 2 次
- 下方只有一个孩子, 则"下坠"一层, 只需对比关键字 1 次

- TODO: Code <2025/09/06, Kuring> -

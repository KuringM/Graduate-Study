# 基数排序 (Radix Sort)

假设⻓度为n的线性表中每个结点aj的关键字由d元组 $(k_j^{d-1},k_j^{d-2}, k_j^{d-3}, \cdots,  k_j^{0}, k_j^{0}$ 组成, 其中,

- $k_j^{d-1}$: 最高位关键字(最主位关键字)
- $k_j^{0}$: 最低位关键字(最次位关键字)
- $0\leqslant k_j^i \leqslant r-1\ (0\leqslant j < n, 0\leqslant i \leqslant d-1$,
- r 称为"基数"

基数排序得到 **递减序列** 的过程如下:

> 基数排序不是基于"比较"的排序算法

- 将整个关键字拆分为d位(或"组")
- 初始化: 设置 r 个空队列, $Q_{r-1}, Q_{r-2}, \cdots, Q_0$, 按照各个 **关键字** **位权重递增的次序** (如: 个、十、百), 对 d 个关键字位分别做"分配"和"收集"
  - 若当前处理的 关键字位 可能取得r个值, 则需要建立r个队列
- **分配**: 顺序扫描各个元素, 若当前处理的关键字位=x, 则将元素插入 $Q_x$ 队尾
- **收集**: 把 $Q_{r-1}, Q_{r-2}, \cdots, Q_0$ 各个队列中的结点依次出队并链接

![[Pasted image 20250906195426.png]]

## 算法效率分析

基数排序通常基于链式存储实现

- 需要 r 个辅助队列, ==空间复杂度 $= O(r)$==
- 一趟分配$O(n)$, 一趟收集$O(r)$, 总共 d 趟分配、收集, 总的==时间复杂度$=O(d(n+r))$==
  > 把关键字拆为d个部分, 每个部分可能取得 r 个值
  > 收集一个队列只需$O(1)$时间
- 稳定性: 稳定的

## 基数排序的应用

基数排序擅⻓解决的问题:

1. 数据元素的关键字可以方便地拆分为 d 组, 且 d 较小
2. 每组关键字的取值范围不大, 即 r 较小
3. 数据元素个数 n 较

![[截屏2025-09-06 20.09.12.png]]

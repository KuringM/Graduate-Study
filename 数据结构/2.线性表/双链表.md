# 双链表的定义

```c
//定义双链表结点类型
typedef struct DNode{
	ElemType data; //数据域
	struct DNode *prior, *next; //前驱和后驱指针
}DNode, *DLinklist;
```

## 初始化

```c
//初始化双链表
bool InitDLinkList(DLinklist &L){
	L = (DLinklist *)malloc(sizeof(DNode)); //分配头结点
	if (L==NULL) return false; //内存不足,分配失败
	L-> prior = NULL; //头结点的 prior 永远指向NULL
	L-> next = NULL; //头结点暂时无后继
	return true;
}

//判断双链表是否为空(带头指针)
bool Empty(DLinklist L){
	if (L->next == NULL)
		return true;
	else
		return false;
}

void testDLinkList(){
	//初始化双链表
	DLinklist L;
	InitDLinkList(L);
	//next code...
}
```

## 双链表的插入

```c
//在p结点之后插入s结点
bool InsertNextDNode(DNode *p, DNode *s){
	if (p==NULL || s==NULL) return true;//非法参数
	s->next=p->next;
	if (p-> next != NULL) { //如果p有后继结点, 将其连接到s
		p->next->prior=s;
	}
	s->prior=p;
	p->next=s;
}
```

时间复杂度:O(1).

## 双链表的删除

```c
//删除p的后继
bool DeleteNextDNode(DNode *p){
	if (p==NULL) return true;//非法参数
	DNode *q = p->next; //找到p的后继q
	if (q==NULL) return false; //p没后继
  p->next=q->next;
	if (q->next!= NULL) //q不是最后的结点
		q->next->prior=p;
	free(q); //释放结点空间
	return true;
}

bool DestoryList(DLinklist &L){
	//循环释放各个数据结点
	while( L-> next != NULL )
		DeleteNextDNode(L);
	free(L);
}
```

时间复杂度:O(1).

## 遍历

```c
//后向遍历
while (p!=NULL){
	//对 结点 p做相应处理, 如打印
	p = p->next;
}

//前向遍历
while (p!=NULL){
	//对结点 p做相应处理
	p = p->prior;
}

//前向遍历(跳过头结点)
while (p-> prior != NULL){
	//对结点 p做相应处理
	p = p->prior;
}
```

双链表不可随机存取, 按位查找、按值查找操作都只能用遍历的方式实现. 时间复杂度 O(n)

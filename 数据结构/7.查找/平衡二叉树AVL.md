# 平衡二叉树

## 平衡二叉树的定义

> G. M. Adelson-Velsky和E. M. Landis

平衡二叉树(Balanced Binary Tree), 简称平衡树(AVL树)--树上任一结点的左子树和右子树的高度之差不超过1.

- **结点的平衡因子** = 左子树高-右子树高
- 平衡二叉树结点的平衡因子的值只可能是−1、0或1.
- 只要有任一结点的平衡因子绝对值大于1, 就不是平衡二叉树

## 平衡二叉树的插入

在二叉排序树中插入新结点后, 如何保持平衡?

- 查找路径上的所有结点都有可能受到影响
- 从插入点往回找到第一个不平衡结点, 调整以该结点为根的子树
- 每次调整的对象都是==最小不平衡子树==

### 调整最小不平衡子树

- LL -- 在A的左孩子的左子树中插入导致不平衡
- RR -- 在A的右孩子的右子树中插入导致不平衡
- LR -- 在A的左孩子的右子树中插入导致不平衡
- RL -- 在A的右孩子的左子树中插入导致不平衡

#### LL

LL平衡旋转(**右单旋转**):

- 由于在结点A的左孩子(L)的左子树(L)上插入了新结点, A的平衡因子由1增至2,导致以A为根的子树失去平衡, 需要一次向右的旋转操作.
- 将A的左孩子 ==B向右上旋转== 代替A成为根结点, 将 ==A结点向右下旋转== 成为B的右子树的根结点, 而B的原右子树则作为A结点的左子树.

![[Pasted image 20250904102817.png]]

```c
// 实现 f 向右下旋转, p 向右上旋转, 其中
//  - f是爹,
//  - p为左孩子,
//  - gf为f他爹.
1. f->lchild = p->rchild;   // p 的右孩子变成 f 的左孩子
2. p->rchild = f;           // p的右孩子变成f
3. gf->lchild / rchild = p; // gf的左/右孩子变成p
```

![[截屏2025-09-04 10.45.05.png]]

#### RR

RR平衡旋转(**左单旋转**):

- 由于在结点A的右孩子(R)的右子树(R)上插入了新结点, A的平衡因子由-1减至-2, 导致以A为根的子树失去平衡, 需要一次向左的旋转操作.
- 将A的右孩子==B向左上旋转==代替A成为根结点, 将A==结点向左下旋转==成为B的左子树的根结点, 而B的原左子树则作为A结点的右子树

![[Pasted image 20250904103256.png]]

```c
// 实现 f 向左下旋转, p 向左上旋转 : 其中
// - f是爹,
// - p为右孩子,
// - gf为f他爹.
1. f->rchild = p->lchild;
2. p->lchild = f;
3. gf->lchild / rchild = p;
```

> 左旋、右旋操作后可以保持二叉排序树的特性

#### LR

LR平衡旋转(**先左后右双旋转**).

- 由于在A的左孩子(L)的右子树(R)上插入新结点, A的平衡因子由1增至2, 导致以A为根的子树失去平衡, 需要进行两次旋转操作, 先左旋转后右旋转.
- 先将A结点的左孩子B的右子树的根结点==C向左上旋转提升到B结点的位置==, 然后再把该==C结点向右上旋转提升到A结点的位置==

![[Pasted image 20250904105553.png]]

#### RL

RL平衡旋转(先右后左双旋转).

- 由于在A的右孩子(R)的左子树(L)上插入新结点, A的平衡因子由-1减至-2, 导致以A为根的子树失去平衡, 需要进行两次旋转操作, 先右旋转后左旋转.
- 先将A结点的右孩子B的左子树的根结点==C向右上旋转提升到B结点的位置==, 然后再把该==C结点向左上旋转提升到A结点的位置==.

## 查找效率分析

- 若树高为h, 则最坏情况下, 查找一个关键字最多需要对比 h 次, 即查找操作的时间复杂度不可能超过 $O(h)$
- 平衡二叉树 -- 树上任一结点的左子树和右子树的高度之差不超过1.
- ==假设以$n_h$表示深度为h的平衡树中含有的最少结点数, 则有$n_0 = 0, n_1 = 1, n_2 = 2, 并且有n_h = n_{h−1} + n_{h−2} + 1$==.
  - $h=3, n_3=4; h=4, n_4=7, h=5, n_5=12$
- 可以证明含有n个结点的平衡二叉树的最大深度为$O(\log_2 n)$, 平衡二叉树的平均查找长度为$O(\log_2 n)$

## 平衡二叉树的删除

平衡二叉树的插入操作:

- 插入新结点后, 要保持二叉排序树的特性不变(`左<中<右`)
- 若插入新结点导致不平衡, 则需要调整平衡

平衡二叉树的删除操作:

- 删除结点后, 要保持二叉排序树的特性不变(`左<中<右`)
- 若删除结点导致不平衡, 则需要调整平衡

平衡二叉树的删除操作具体步骤:

1. 删除结点(方法同"二叉排序树")
   - 若删除的结点是叶子, 直接删.
   - 若删除的结点只有一个子树, 用子树顶替删除位置
   - 若删除的结点有两棵子树, 用前驱(或后继)结点顶替, 并转换为对前驱(或后继)结点的删除
2. 一路向北==找到最小不平衡子树==, 找不到就完结撒花
3. 找最小不平衡子树下, "个头"最高的儿子、孙子
   - ==孙子在LL: 儿子右单旋==
   - ==孙子在RR: 儿子左单旋==
   - ==孙子在LR: 孙子先左旋, 再右旋==
   - ==孙子在RL: 孙子先右旋, 再左旋==
4. 根据孙子的位置, 调整平衡(LL/RR/LR/RL)
5. 如果==不平衡向上传导==, 继续2
   - 对最小不平衡子树的旋转可能导致树变矮, 从而导致上层祖先不平衡(不平衡向上传递)

平衡二叉树删除操作时间复杂度=$O(\log_2 n)$

# B树及其基本操作

m叉树如何保证查找效率?

- 策略: m叉查找树中, 规定除了根节点外, 任何结点至少有 $\lceil \frac{m}{2} \rceil$ 个分叉, 即至少含有 $\lceil \frac{m}{2} \rceil - 1$ 个关键字.
- 策略: m叉查找树中, 规定对于任何一个结点, 其所有子树的高度都要相同.

## B树的定义

**B树**, 又称**多路平衡查找树**, B树中所被允许的孩子个数的最大值称为B树的阶, 通常用m表示.
一棵**m阶B树**或为空树, 或为满足如下特性的m叉树:

1. 树中每个结点至多有m棵子树, 即至多含有m-1个关键字.
2. 若根结点不是终端结点, 则至少有2棵子树, 即至少含有1个关键字.
3. ==除根结点外的所有非叶结点至少有 $\lceil \frac{m}{2} \rceil$ 棵子树, 即至少含有 $\lceil \frac{m}{2} \rceil - 1$ 个关键字==.
4. 所有非叶结点的结构如下:
   $$
   \colorbox{gray}{\textcolor{black}{$ n $}}\
   \colorbox{gray}{\textcolor{black}{$ P_0 $}}\
   \colorbox{gray}{\textcolor{black}{$ K_1 $}}\
   \colorbox{gray}{\textcolor{black}{$ P_1 $}}\
   \colorbox{gray}{\textcolor{black}{$ K_2 $}}\
   \colorbox{gray}{\textcolor{black}{$ P_2 $}}\
   \colorbox{gray}{\textcolor{black}{$ \cdots $}}\
   \colorbox{gray}{\textcolor{black}{$ K_n $}}\
   \colorbox{gray}{\textcolor{black}{$ P_n $}}\
   $$
   - 其中, $K_i(i = 1, 2, \cdots, n)$为结点的关键字,且满足$K_1 < K_2 < \cdots < K_n$;
   - $P_i(i = 0, 1,\cdots, n)$为指向子树根结点的指针,
     - 且指针$P_{i-1}$所指子树中所有结点的关键字均小于$K_i$,
     - $P_i$所指子树中所有结点的关键字均大于$K_i$;
   - $n( \lceil \frac{m}{2} \rceil- 1 \leqslant n \leqslant m - 1)$为结点中关键字的个数.
5. 所有的叶结点都出现在同一层次上, 并且不带信息(可以视为外部结点或类似于折半查找判定树的查找失败结点, 实际上这些结点不存在, 指向这些结点的指针为空).

![[Pasted image 20250904164410.png]]

**m阶B树**的核心特性:

1. 根节点的子树数$\in [2, m]$, 关键字数$\in [1, m-1]$.
   - 其他结点的子树数$\in [ \lceil \frac{m}{2} \rceil, m]$;关键字数$\in [ \lceil \frac{m}{2} \rceil, m-1 ]$
2. 对任一结点, 其所有子树高度都相同
3. 关键字的值: `子树0<关键字1<子树1<关键字2<子树2<....` (类比二叉查找树 `左<中<右`)

### B树的高度

> 注: 大部分学校算B树的高度不包括叶子结点(失败结点)

问题: 含n个关键字的m阶B树, 最小高度、最大高度是多少?

$$
\log_2(n+1) \leqslant  h \leqslant \log_{\lceil \frac{m}{2} \rceil} \frac{n+1}{2} + 1
$$

最小高度

- 让每个结点尽可能的满, 有m-1个关键字, m个分叉,
- 则有$n \leqslant (m-1)(1+m+m^2+ \cdots+ m^{h-1} = m^{h}-1$, 因此 ==$h \geqslant \log_2(n+1)$==.

最大高度

- 让各层的分叉尽可能的少, 即根节点只有2个分叉, 其他结点只有 $\lceil \frac{m}{2} \rceil$个分叉.
- 各层结点至少有: 第一层 1、 第二层 2、第三层 $2\lceil \frac{m}{2} \rceil$ ... 第h层 $2(\lceil \frac{m}{2} \rceil)^{h-2}$.
- 第h+1层共有叶子结点(失败结点) $2(\lceil \frac{m}{2} \rceil)^{h-1}$个.
- ==n个关键字的B树必有n+1个叶子结点==, 则 $n+1 \geqslant 2(\lceil \frac{m}{2} \rceil)^{h-1}$,
  即==$h \leqslant \log_{\lceil \frac{m}{2} \rceil} \frac{n+1}{2} + 1$==.
  > n个关键字将数域切分为n+1个区间

![[Pasted image 20250904173150.png]]

## B树的查找

相似与二叉排序树.

## B树的插入

核心要求:

1. 对m阶B树 -- 除根节点外, 结点关键字个数 $\lceil \frac{m}{2} \rceil \leqslant n \leqslant m- 1$;
2. `子树0<关键字1<子树1<关键字2<子树2<....`.
3. 新元素一定是插入到最底层"终端节点", 用"查找"来确定插入位置.
4. 在插入key后,
   1. 若导致原结点关键字数超过上限, 则从中间位置==$\lceil \frac{m}{2} \rceil$==将其中的关键字分为两部分,
   2. 左部分包含的关键字放在原结点中, 右部分包含的关键字放到新结点中, 中间位置==$\lceil \frac{m}{2} \rceil$==的结点插入原结点的父结点
   3. 若此时导致其父结点的关键字个数也超过了上限, 则继续进行这种分裂操作, 直至这个过程传到根结点为止, 进而导致B树高度增1.

## B树的删除

若被删除关键字在终端节点, 则直接删除该关键字(要注意节点关键字个数是否低于下限 $\lceil \frac{m}{2} \rceil - 1$)

若被删除关键字在非终端节点, 则用直接前驱或直接后继来替代被删除的关键字.

- 直接前驱: 当前关键字左侧指针所指子树中"最右下"的元素
- 直接后继: 当前关键字右侧指针所指子树中"最左下"的元素

兄弟够借. 若被删除关键字所在结点删除前的关键字个数低于下限,
且与此结点右(或左)兄弟结点的关键字个数还很宽裕, 则需要调整该结点、右(或左)兄弟结点及其双亲结点(父子换位法)

- 当右兄弟很宽裕时, 用当前结点的后继、后继的后继 来填补空缺
- 当左兄弟很宽裕时, 用当前结点的前驱、前驱的前驱 来填补空缺

兄弟不够借. 若被删除关键字所在结点删除前的关键字个数低于下限,
且此时与该结点相邻的左、右兄弟结点的关键字个数均= $\lceil \frac{m}{2} \rceil - 1$ , 则将关键字删除后与左(或右)兄弟结点及双亲结点中的关键字进行合并

在合并过程中, 双亲结点中的关键字个数会减1.
若其双亲结点是根结点且关键字个数减少至0(根结点关键字个数为1时, 有2棵子树), 则直接将根结点删除, 合并后的新结点成为根;
若双亲结点不是根结点, 且关键字个数减少到 $\lceil \frac{m}{2} \rceil - 2$, 则又要与它自己的兄弟结点进行调整或合并操作, 并重复上述步骤, 直至符合B树的要求为止.


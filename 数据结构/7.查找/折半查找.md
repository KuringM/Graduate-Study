# 折半查找

## 折半查找的算法思想

折半查找, 又称"二分查找", 仅适用于==有序的顺序表==.

算法思想:

- 在`[low, high]`之间找目标关键字, 每次检查 `mid=(low+high)/2`
- 根据`mid`所指元素与目标关键字的大小调整 `low`或`high`, 不断缩小 `low` 和 `high` 的范围
- 若 `low> high`则查找失败
  > 顺序表拥有随机访问的特性, 链表没有. <BR>
  > 只有在 `[low, high]` 之间才有可能找到目标关键字

## 折半查找的实现

```c
typedef struct {  // 查找表的数据结构(顺序表)
  ElemType *elem; // 动态数组基址
  int TableLen;   // 表的长度
} SSTable;

// 折半查找, 数据按升序排列, 下标从0开始
int Binary_Search(SSTable L, ElemType key) {
  int low = 0, high = L.TableLen - 1, mid;
  while (low <= high) {
    mid = (Low + high) / 2; // 取中间位置
    if (L.elem[mid] = key)
      return mid; // 查找成功则返回所在位置
    else if (L.elem[mid] > key)
      high = mid - 1; // 从前半部分继续查找
    else
      Low = mid + 1; // 从后半部分继续查找
  }
  return -1; // 查找失败, 返回-1
}
```

### 查找效率分析

![[Pasted image 20250903161900.png]]

## 折半查找判定树的构造

$$
\text{mid} = \left\lceil \frac{\text{low} + \text{high}}{2}  \right\rceil
$$

由mid所指元素将原有元素分割到左右子树中

- 如果当前low和high之间有奇数个元素, 则 mid 分隔后, 左右两部分元素个数相等
- 如果当前low和high之间有偶数个元素, 则 mid 分隔后, 左半部分比右半部分少一个元素

折半查找的判定树中, 若`mid= [(low+high)/2]`, 则对于任何一个结点,
必有: 右子树结点数-左子树结点数=0或1

- 折半查找的判定树一定是平衡二叉树
- 折半查找的判定树中, 只有最下面一层是不满的
- 因此, 元素个数为n时树高$h= [\log_2(n + 1)]$
  > 注: 计算方法同"完全二叉树"
- 判定树结点关键字: `左<中<右`, 满足二叉排序树的定义
- 失败结点: n+1个(等于成功结点的空链域数量)

## 折半查找的查找效率

- 树高$h= \lceil \log_2(n + 1) \rceil$
  > 注: 该树高不包含失败结点, 若包含则h= h+1.
- 查找成功的`ASL <= h`
- 查找失败的`ASL <= h`
- 折半查找的时间复杂度 = $O(\log_2 n)$

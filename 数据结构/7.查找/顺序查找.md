# 顺序查找

- 时间复杂度: $O(n)$

## 顺序查找的算法思想

- 顺序查找, 又叫"线性查找", 通常用于线性表.
- 算法思想: 从头到 jio 挨个找(或者反过来也OK)
- 适用于顺序表、链表, 表中元素有序无序都OK

## 顺序查找的算法实现

```c
typedef struct {  // 查找表的数据结构(顺序表)
  ElemType *elem; // 动态数组基址
  int TableLen;   // 表的长度
} SSTable;

// 顺序查找
int Search_Seq(SSTable ST, ElemType key) {
  int i; // 数据从下标0开始存
  for (i = 0; i < ST.TableLen && ST.elem[i] != key; ++i)
    ;
  // 查找成功, 则返回元素下标;查找失败, 则返回-1
  return i == ST.TableLen ? -1 : i;
}
```

## 顺序查找的算法实现(哨兵)

```c
typedef struct {  // 查找表的数据结构(顺序表)
  ElemType *elem; // 动态数组基址
  int TableLen;   // 表的长度
} SSTable;

// 顺序查找
int Search_Seq(SSTable ST, ElemType key) {
  ST.elem[0] = key; // 0号位置存"哨兵", 数据从下标1开始存
  int i;
  for (i = ST.TableLen; ST.elem[i] != key; --i)
    ;       // 从后往前找
  return i; // 查找成功, 则返回元素下标;查找失败, 则返回0
}
```

优点: 无需判断是否越界, 效率更高.

### 查找效率分析

- $ASL_{成功}= \frac{1+2+3+\cdots+n}{n}= \frac{n+1}{2}$
- $ASL_{失败}= n+1$
- 时间复杂度: $O(n)$

## 顺序查找的优化(对有序表)

有序表: 查找表中元素有序存放(递增/递减).

当前关键字大于(或小于)目标关键字时, 查找失败.

- $ASL_{失败}= \frac{1+2+\cdots+ n+ n}{n+1} = \frac{n}{2}+ \frac{n}{n+1}$
- $ASL_{成功}= \frac{1+2+3+\cdots+n}{n}= \frac{n+1}{2}$

优点: 查找失败是ASL更少.

### 查找判定树

![[Pasted image 20250903160406.png]]

- 一个成功结点的查找⻓度 = 自身所在层数
- 一个失败结点的查找⻓度 = 其父节点所在层数
- 默认情况下, 各种失败情况或成功情况都等概率发生

## 顺序查找的优化(被查概率不相等)

被查概率大的放在靠前位置, 可按被查概率降序排列.

优点: 查找成功时ASL更少

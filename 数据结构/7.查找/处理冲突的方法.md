# 处理冲突的方法

[OpenHash](https://www.cs.usfca.edu/~galles/visualization/OpenHash.html)

## 拉链法

**拉链法**(又称链接法、链地址法): 把所有**同义词**存储在一个链表中.

### 散列表的插入操作

如何在散列表(拉链法解决冲突)中插入一个新元素?

- Step 1: 结合散列函数计算新元素的散列地址
- Step 2: 将新元素插入散列地址对应的链表(可用头插法, 也可用尾插法)

#### 插入操作的小优化

- 新元素用**头插法**插入链表, 每个链表是乱序的.
- 新元素插入链表时, 若能保持链表有序, 可以略微提高**查找**效率.

### 散列表的查找操作

查找⻓度 -- 在查找运算中, 需要对比关键字的次数称为查找⻓度

- Step 1: 根据散列函数计算目标元素的散列地址
- Step 2: 顺序查找散列地址对应的链表, 直到查找成功或查找失败
- 在分析查找长度时, 通常只统计**关键字的对比次数**, 而链表**空指针的对比次数**不计入查找长度
  > 注: 有的教材会把**空指针的对比**也计入查找⻓度. 但考试中默认只统计**关键字对比次数**.

### 散列表的删除操作

- Step 1: 根据散列函数计算目标元素的散列地址
- Step 2: 顺序查找散列地址对应的链表, 若查找成功, 将目标元素从链表中删除

## 开放定址法

开放定址法: 如果发生**冲突**, 就给新元素找另一个空闲位置.

为什么叫**开放定址**? -- 一个散列地址, 既对同义词开放, 也对非同义词开放.

待解决的问题: 用什么规则确定**另一个空闲位置**?

- 思路: 需确定一个**探测的顺序**, 从初始散列地址出发, 去寻找下一个空闲位置.
- 探测的顺序(增量序列), e.g.: $d_0=0, d_1=1, d_2=-1, d_3=2, d_4=-2, \cdots$
- 注: $d_i$ 表示第 i 次发生冲突时, 下一个探测地址与初始散列地址的相对偏移量.

### 开放定址法的基本原理

根据散列函数 `H(key)`, 求得初始散列地址.
若发生冲突, 如何找到**另一个空闲位置**?

$$
H_i = (H(key)+d_i) \% m
$$

- $H_i$: 发生第 i 次冲突时的散列地址
- $H(key)$: 初始散列地址
- $d_i$: 偏移量
- $m$: 散列表表长

四种常用方法构造探测序列$d_i$

> 注: $0\leqslant i \leqslant m-1$

- 线性探测法: $d_i = 0,1,2,3, \cdots, m-1$
- 平方探测法: $d_i = 0^2,1^2 , -1^2,2^2, -2^2, \cdots, K^2, -K^2. 其中K \leqslant \frac{m}{2}$.
  > 又称"二次探测法"
- 双散列法: $d_i = i \times hash_2(key)$. 其中 $hash_2(key)$是另一散列函数.
- 伪随机序列法: $d_i$是一个伪随机序列, 如$d=0, 5,3, 11, \cdots$

**插入操作**, 根据探测序列依次探寻偏移地址.

- 若地址为空, 则插入;
- 若地址不空, 则继续探测.

注: **查找操作**原理类似, 根据探测序列依次对比各存储单元内的关键字.

- 若探测到目标关键字,则查找成功.
- 若探测到空单元, 则查找失败.

**删除操作**
如何删除一个元素:

- Step 1: 先根据散列函数算出散列地址, 并对比关键字是否匹配. 若匹配, 则"查找成功"
- Step 2: 若关键字不匹配, 则根据"探测序列"对比下一个地址的关键字, 直到"查找成功"或"查找失败"
- Step 3: 若"查找成功", 则删除找到的

注意:
采用"开放定址法"时, 删除元素不能简单地将被删元素的空间置为空,
否则将截断在它之后的探测路径, 可以做一个"已删除"标记, 进行**逻辑删除**.

> - 无论线性探测法、平方探测法、双散列法、伪随机序列法原理都一样. 删除元素时, 只能逻辑删除.
> - 新元素也可以插入到已被"逻辑删除"的地址

逻辑删除带来的问题: 查找效率低下, 散列表看起来很满, 实则很空.

- Tips: 可以不定期整理散列表内的数据, 进行物理删除.

### 线性探测法的"探测覆盖率

采用线性探测法, 一定可以探测到散列表的每个位置只要散列表中有空闲位置, 就一定可以插入成功

- 理想情况下, 若散列表表⻓=m, 则最多发生 m-1 次冲突即可"探测"完整个散列表.

采用平方探测法, 至少可以探测到散列表中一半的位置这意味着,
即便散列表中有空闲位置, 也未必能插入成功.

- 若散列表⻓度 m 是一个可以表示成4j + 3的素数(如 7、11、19), 平方探测法就能探测到所有位置

双散列法未必能探测到散列表的所有位置.

- 双散列法的探测覆盖率取决于第二个散列函数 $hash_2(key)$ 设计的是否合理.
- 若$hash2_(key)$ 计算得到的值与散列表表⻓m互质, 就能保证双散列发可以探测所有单元.
  - 双散列法常用套路: 令表⻓m本身就是质数, $hash_2(key)=m-(key\% m)$, 无论 key 值是多少, $hash_2(key)$ 和 m 一定互质.

伪随机序列法: $d_i$ 是一个伪随机序列, 由程序员人为设计

- 采用伪随机序列法, 是否能探测到散列表中全部位置, 取决于伪随机序列的设计是否合理

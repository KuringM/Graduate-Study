# 栈在表达式求值中的应用

算数表达式由三个部分组成:操作数、运算符、界限符.

波兰数学家的灵感

- Reverse Polish notation(逆波兰表达式= 后缀表达式)
- Polish notation(波兰表达式= 前缀表达式)

| 中缀表达式             | 后缀表达式             | 前缀表达式             |
| ---------------------- | ---------------------- | ---------------------- |
| 运算符在两个操作数中间 | 运算符在两个操作数后面 | 运算符在两个操作数前面 |
| $a+b-c \times d$       | $ab+ cb \times -$      | $-+ab \times cd$       |

## 中缀转后缀

**中缀转后缀**的手算方法:

1. 确定中缀表达式中各个运算符的运算顺序
2. 选择下一个运算符, 按照「左操作数右操作数 运算符」的方式组合成一个新的操作数
3. 如果还有运算符没被处理, 就继续2

> 运算顺序不唯一, 因此对应的后缀表达式也不唯一

**"左优先"**原则:只要左边的运算符能先计算, 就优先算左边的, 可保证运算顺序唯一.

后缀表达式的手算方法:
从左往右扫描, 每遇到一个运算符, 就让运算符前面最近的两个操作数执行对应运算,合体为一个操作数.

> 特点: 最后出现的操作数先被运算(LIFO 后进先出)

$$
\begin{aligned}
	& ((15 ÷ (7 − (1 + 1))) × 3) − (2 + (1 + 1))\\
	& 15 7 1 1 + - ÷ 3 × 2 1 1 + + -
\end{aligned}
$$

## 中缀表达式转后缀表达式(机算)

用栈实现后缀表达式的计算:

1. 从左往右扫描下一个元素, 直到处理完所有元素
2. 若扫描到操作数则压入栈, 并回到1;否则执行3
3. 若扫描到运算符, 则弹出两个栈顶元素, 执行相应运算, 运算结果压回栈顶, 回到1

用栈实现中缀表达式转后缀表达式:

1. 初始化一个栈, 用于保存**暂时还不能确定运算顺序的运算符**.
2. 从左到右处理各个元素, 直到末尾. 可能遇到三种情况:

   1. 遇到**操作数**. 直接加入后缀表达式.
   2. 遇到**界限符**. 遇到"("直接入栈;遇到")"则依次弹出栈内运算符并加入后缀表达式, 直到弹出"("为止. 注意:"("不加入后缀表达式.
   3. 遇到**运算符**. 依次弹出栈中优先级高于或等于当前运算符的所有运算符, 并加入后缀表达式,若碰到"(" 或栈空则停止. 之后再把当前运算符入栈.

按上述方法处理完所有字符后, 将栈中剩余运算符依次弹出, 并加入后缀表达式.

### 用栈实现 `A + B* (C - D)- E / F` 转后缀表达式 `ABCD-*+EF/-`

| 步骤 | 扫描项 | 动作          | 栈中内容 | 后缀表达式   |
| ---- | ------ | ------------- | -------- | ------------ |
| 1    | A      |               |          | A            |
| 2    | +      | Push          | +        | A            |
| 3    | B      |               | +        | AB           |
| 4    | \*     | Push          | + \*     | AB           |
| 5    | (      | Push          | + \* (   | AB           |
| 6    | C      |               | + \* (   | ABC          |
| 7    | -      | Push          | + \* ( - | ABC          |
| 8    | D      |               | + \* ( - | ABCD         |
| 8    | )      | Pop           | + \*     | ABCD-        |
| 9    | -      | Pop then Push | -        | ABCD-\*+     |
| 10   | E      |               | -        | ABCD-\*+E    |
| 10   | /      | Push          | - /      | ABCD-\*+E    |
| 11   | F      | Pop           |          | ABCD-\*+EF/- |

## 中缀表达式的计算(用栈实现)

> 中缀转后缀 + 后缀表达式求值 两个算法的结合

用栈实现中缀表达式的计算:

1. 初始化两个栈, *操作数栈*和*运算符栈*
2. 若扫描到操作数, 压入操作数栈
3. 若扫描到运算符或界限符, 则按照"中缀转后缀"相同的逻辑压入运算符栈
   (期间也会弹出运算符, 每当弹出一个运算符时,
   就需要再弹出两个操作数栈的栈顶元素并执行相应运算,
   运算结果再压回操作数栈)

### 用栈实现 `A + B* (C - D)- E / F` 转后缀表达式 `ABCD-*+EF/-`

| 步骤 | 扫描项 | 动作          | 运算符栈 | 操作符栈         |
| ---- | ------ | ------------- | -------- | ---------------- |
| 1    | A      | Push          |          | `A`              |
| 2    | +      | Push          | +        | `A`              |
| 3    | B      | Push          | +        | `A` `B`          |
| 4    | \*     | Push          | + \*     | `A` `B`          |
| 5    | (      | Push          | + \* (   | `A` `B`          |
| 6    | C      | Push          | + \* (   | `A` `B` `C`      |
| 7    | -      | Push          | + \* ( - | `A` `B` `C`      |
| 8    | D      | Push          | + \* ( - | `A` `B` `C` `D`  |
| 8    | )      | Pop           | + \*     | `A` `B` `C-D`    |
| 9    | -      | Pop then Push | -        | `(C-D)\*B+A`     |
| 10   | E      | Push          | -        | `(C-D)\*B+A` `E` |
| 10   | /      | Push          | - /      | `(C-D)\*B+A` `E` |
| 11   | F      | Push then Pop |          | `E/F-(C-D)\*B+A` |

## 中缀转前缀

中缀转前缀的手算方法:

1. 确定中缀表达式中各个运算符的运算顺序
2. 选择下一个运算符, 按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数
3. 如果还有运算符没被处理, 就继续 2

"右优先"原则:只要右边的运算符能先计算, 就优先算右边的.

用栈实现前缀表达式的计算:

1. 从右往左扫描下一个元素, 直到处理完所有元素
2. 若扫描到操作数则压入栈, 并回到1;否则执行3
3. 若扫描到运算符, 则弹出两个栈顶元素, 执行相应运算, 运算结果压回栈顶, 回到1

> 注意:先出栈的是"左操作数"

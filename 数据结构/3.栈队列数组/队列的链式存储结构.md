# 队列的链式存储结构

## 定义

```c
typedef struct LinkNode{ //链式队列结点
	ElemType data;
	struct LinkNode *next;
}LinkNode;

typedef struct { //链式队列
	LinkNode *front, *rear; //队头、队尾
}LinkQueue;
```

## 初始化

### 带头结点

```c
void InitQueue(LinkQueue &Q){
	//初始时 , front rear 都指向头结点
	Q.front = Q.rear =(LinkNode*) malloc ( sizeof(LinkNode) );
	Q.front -> next = NULL;
}

//判断队列是否为空
bool IsEmpty(LinkQueue Q){
	if(Q.front == Q.rear) return true;
	else return false;
}

void testLinkQueue(){
	LinkQueue Q; //声明一个队列
	InitQueue(Q); //初始化队列
	// ... next code ...
}

```

### 不带头结点

```c
void InitQueue(LinkQueue &Q){
	//初始时 , front rear 都指向NULL
	Q.front = Q.rear = NULL;
}

//判断队列是否为空
bool IsEmpty(LinkQueue Q){
	if(Q.front == NULL) return true;
	else return false;
}
```

## 入队

### 带头结点

```c
//新元素入队(带头结点)
void EnQueue(LinkQueue &Q, ElemType x){
	LinkNode *s= (LinkNode *)malloc(sizeof(LinkNode));
	s->data=x;
	s->next=NULL;
	Q.rear->next=s;//新结点插入到rear之后
	Q.rear=s;//修改表尾指针
}
```

### 不带头结点

```c
//新元素入队(不带头结点)
void EnQueue(LinkQueue &Q, ElemType x){
	LinkNode *s= (LinkNode *)malloc(sizeof(LinkNode));
	s->data=x;
	s->next=NULL;
	if(Q.front == NULL){ //在空队列中插入第一个元素
	//修改队头、队尾指针
		Q.front = s;
		Q.rear = s
	}
	else{
		Q.rear->next=s;//新结点插入到rear之后
		Q.rear=s;//修改表尾指针
	}
}
```

## 出队

### 带头结点

```c
//新元素出队(带头结点)
void DeQueue(LinkQueue &Q, ElemType x){
	if(Q.front == Q.rear) return false; //空队

	LinkQueue *p = Q.front -> next;  //头结点下个结点(队头)
	x=p->data; //用x返回队头元素
	Q.front-> next = p ->next; //头结点指向队头下个结点

	if(Q.rear == p) Q.rear= Q.front; // 若为最后一个结点, 修改队尾指针

	free(p); //释放队头结点空间

	return true;
}
```

### 不带头结点

```c
//新元素出队(不带头结点)
void DeQueue(LinkQueue &Q, ElemType x){
	if(Q.front = NULL) return false; //空队

	LinkQueue *p = Q.front ;  //p指向队头结点
	x=p->data; //用x返回队头元素
	Q.front = p ->next; // front 指向队头下个结点

	if(Q.rear == p) {
		Q.rear= Q.front = NULL; // 若为最后一个结点, 修改队头、队尾指针
	}

	free(p); //释放队头结点空间

	return true;
}
```

## 队列满的条件

- 链式存储: 一般不会队满, 除非内存不足.
- 顺序存储: 预分配的空间耗尽时队满.

# 队列的顺序存储结构

## 定义

```c
#define MaxSize 10//定义队列中元素的最大个数
typedef struct{
	ElemType data [MaxSize];//用静态数组存放队列元素
	int front, rear; //队头指和队尾指针心
}SqQueue;
```

## 初始化

```c
void InitQueue(SqQueue &Q){
	// 初始时 队头、队尾指针指向0
	Q.rear = Q.front = 0;
}
```

## 入队

```c
bool EnQueue(SqQueue &Q, ElemType x){
	if(队满) return fasle; //队满报错
	Q.data[Q.rear] = x; //将x插入队尾
	Q.rear=Q.rear+1; //队尾指针后移
	return true;
}
```

- Q.rear==MaxSize不能作为队列满的条件
- 只有⼀个元素仍满⾜该条件(假溢出)

## 循环队列

![[Pasted image 20250811162933.png]]

- `Q.rear=(Q.rear+1)%MaxSize`: 将存储空间在逻辑上变成了"环状".

### 区分队满队空的三种处理方式

#### 1. 牺牲一个存储单元:

- 队空条件: `Q.front = Q.rear`
- 队满条件: `(Q.rear+1)%Maxsize == Q.front`
- 队列元素个数: `(Q.rear - Q.front + MaxSize) % MaxSize`

#### 2. 设置`size`数据成员

删除元素成功, 则`size-1`; 插入元素成功, 则`size + 1`

- 队空条件: `Q.size = 0`
- 队满条件: `Q.size = MaxSize`
- 队列元素个数: `size`

#### 3. 设置`tag`数据成员

- 删除元素成功, 则`tag=0`, 若导致`Q.front == Q.rear`, 则为队空;
- 插入元素成功, 则`tag=1`, 若导致`Q.front == Q.rear`, 则为队满;

### 循环队列初始化

```c
void InitQueue(SqQueue &Q){
	// 初始时 队头、队尾指针指向0
	Q.rear = Q.front = 0;
}
```

### 循环队列入队

```c
bool EnQueue(SqQueue &Q, ElemType x){
	if((Q.rear +1)%Maxsize == Q.front) return false; //队满报错
	Q.data[Q.rear] = x; //将x插入队尾
	Q.rear=(Q.rear+1)%MaxSize; //队尾指针加1取模
	return true;
}
```

### 循环队列出队

```c
bool DeQueue(SqQueue &Q, ElemType x){
	if(Q.rear == Q.front) return false; //队满报错
	x = Q.data[Q.front] ; //将x插入队尾
	Q.front=(Q.front+1)%MaxSize; //队尾指针加1取模
	return true;
}
```

### 读队头元素

```c
bool GetHead(SqQueue &Q, ElemType x){
	if(Q.rear == Q.front) return false; //队满报错
	x = Q.data[Q.front] ;
	return true;
}
```

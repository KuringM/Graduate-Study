# 串的存储结构

## 串的顺序存储

> 结合顺序表的知识思考优缺点

### 静态数组实现(定长顺序存储)

```c
#define MAXLEN 255 //预定义最大串长为255
typedef struct{
	char ch[MAXLEN]; //每个分量存储一个字符
	int length; //串的实际长度
}SString;

```

分配连续的存每个char 字

### 动态数组实现(堆分配存储)

```c
#define MAXLEN 255 //预定义最大串长为255
typedef struct{
	char *ch; //按串长分配存储区, ch指向串的基地址
	int length; //串的长度
}HString;

HString S;
S.ch = (char *) malloc(MAXLEN * sizeof(char)); //malloc在内存中生成堆区, 用完需要手动free
S.length = 0;
```

### 三种定义方案

![[截屏2025-08-31 20.56.30.png]]

## 串的链式存储

> 结合链表的知识思考优缺点

方法一

```c
typedef struct StringNode{
	char ch;//每个结点存1个字符 //1B
	struct StringNode * next; //4B
}StringNode, * String;
```

![[Pasted image 20250831210006.png]]

方法二

```c
typedef struct StringNode{
	char ch[4]; //每个结点存多个字符
	struct StringNode * next;
}StringNode, * String;
```

![[Pasted image 20250831210017.png]]

## 基于顺序存储实现基本操作

### 求子串

- `SubString(&Sub,S,pos,len)`: 求子串. 用Sub返回串S的第pos个字符起长度为len的子串.

```c
#define MAXLEN 255 //预定义最大串长为255
typedef struct{
	char ch[MAXLEN]; //每个分量存储一个字符
	int length; //串的实际长度
}SString;

bool SubString(SString &Sub, SString S, int pos, int len){
	//子串范围越界
	if (pos+len-1 > S. length)
		return false;

	for (int i=pos; i<pos+len; i++)
		Sub.ch [i-pos+1] = S.ch[il;

	Sub. length = len;
	return true;
}
```

### 比较操作

- `StrCompare(S,T)`: 比较操作.
  - 若 `S>T`, 则返回值`>0`;
  - 若 `S=T`, 则返回值`=0`;
  - 若 `S<T`, 则返回值`<0`.

```c
//比较操作. 若S>T, 则返回值>0; 若S=T, 则返回值=0; 若S<T, 则返回值<0
int StrCompare(SString S, SString T) {
	for (int i=1; i<=S.length && i<=T.length; i++){
	if (S.ch[i] != T.ch[i])
		return S.ch [il-T.ch[il;
	}

	//扫描过的所有字符都相同, 则长度长的串更大
	return S. length-T. length;
}
```

### 定位操作

- `Index(S,T)`: 定位操作. 若主串S中存在与串T值相同的子串, 则返回它在主串S中第一次出现的

```c
int Index(SString S, SString T){
	int i=1, n=StrLength(S), m=StrLength(T);
	String sub; //用于暂存子串

	while(i<=n-m+1){ //最多对⽐ n-m+1 个⼦串
		SubString (sub,S,i,m); //取出从位置i开始, ⻓度为m的⼦串
		if (StrCompare (sub, T)!=0) ++i; //⼦串和模式串对⽐, 若不匹配, 则匹配下⼀个⼦串
		else return i; //返回子串在主串中的位置
	}

	return 0; //S中不存在与T相等的子串
}
```

# 简单的模式匹配算法

**字符串模式匹配**: 在**主串**中找到与**模式串**相同的**子串**, 并返回其所在位置.

**朴素模式匹配算法**:
将主串中所有⻓度为m的子串依次与模式串对比, 直到找到一个完全匹配的子串, 或所有的子串都不匹配为止.

- 主串⻓度为n, 模式串⻓度为 m
- **最多对比 n-m+1 个子串**

![[串的存储结构#定位操作]]

接下来不使用字符串的基本操作, 直接通过数组下标实现朴素模式匹配算法.

- 设主串⻓度为 n, 模式串⻓度为 m
- 将主串中所有长度为m的子串与模式串对比
  - 若当前子串匹配失败, 则 **主串指针i** 指向下一个子串的第一个位置, **模式串指针j** 回到模式串的第一个位置.
  - 若 `j > T.length`, 则当前子串匹配成功, 返回当前子串第一个字符的位置 -- `i - T.length`
  - 若所有子串都不匹配, 则返回O
- **最坏时间复杂度 = O(nm)**
  - 最坏的情况, 每个子串都要对比 m 个字符, 共 n-m+1 个子串, 复杂度 = O((n-m+1)m) = O(nm)
    > 注: 很多时候, n >> m

```c
int Index(SString S,SString T){
	int i=1,j=1;

	while(i<=S.length && j<=T.length){
	if(S.ch[i]=T.ch[j]){
		++i; ++j; //继续比较后继字符
	}
	else{
		i = i-j+2;
		j = 1; //指针后退重新开始匹配
	}

	if (j>T.length)
		return i - T.length;
	else
		return 0;
}
```

^a5030a

# 二叉树的存储结构

## 二叉树的顺序存储

定义一个长度为MaxSize的数组t,按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点.

```c
#define MaxSize 100
struct TreeNode {
  ElemType value; // 结点中的数据元
  bool isEmpty;   // 结点是否为空
};

TreeNode t[MaxSize];

// 初始化时所有结点标记为空

for (int i = 0; i < MaxSize; i++) {
  t[i].isEmpty = true;
}

// 可以让第一个位置t[0]空缺,保证数组下标和结点编号一致
```

![[Pasted image 20250906160927.png]]

几个重要常考的基本操作:

- i 的左孩子 -- 2i
- i 的右孩子 -- 2i+1
- i 的父节点 -- $\lfloor i/2 \rfloor$
- i 所在的层次 -- $\lceil \log_2(n+1) \rceil或\lfloor \log_2 n \rfloor+ 1$

若完全二叉树中共有n个结点,则

- 判断 i 是否有左孩子? -- $2i \leqslant  n$ ?
- 判断 i 是否有右孩子? -- $2i+1 \leqslant  n$ ?
- 判断 i 是否是叶子/分支结点? -- $i > \frac{n}{2}$ ?

二叉树的顺序存储中, ==一定要把二叉树的结点编号与完全二叉树对应起来==.

> 对于非完全二叉树(一般二叉树)来说, 为了让数组下表能正确反映二叉树之间的逻辑关系, 需要添加一些空结点.

- 最坏情况: 高度为 h 且只有 h 个结点的单支树(所有结点只有右孩子),也至少需要 $2^{h}-1$ 个存储单元.
- 结论: 二叉树的顺序存储结构, 只适合存储完全二叉树

## 二叉树的链式存储

```c
struct ElemType {
  int value;
};

// 二叉树的结点(链式存储)
typedef struct BiNodet {
  ElemType data;                   // 数据域
  struct BiTNode *lchild, *rchild; // 左、右孩子指针
  struct BiTNode *parent; // 父指针 三叉链表--方便找父结点, 考研中一般不带
} BiTNode, *BiTree;

// 定义一棵空树
BiTree root = NULL;

// 插入根节点
root = (BiTree)malloc(sizeof(BiTNode));
root->data = {1};
root->lchild = NULL;
root->rchild = NULL;

// 插入新结点
BiNode *p = (BiTNode *)malloc(sizeof(BiTNode));
p->data = {2};
p->lchild = NULL;
p->rchild = NULL;
root->lchild = p; // 作为根节点的左孩子
```

n个结点的二又链表共有 n+1个空链域, 可以用于构造线索二叉树.

![[Pasted image 20250901134600.png]]

- 找到指定结点 p 的左/右孩子 -- 超简单
- 如何找到指定结点 p 的父结点? -- 只能从根开始遍历寻找; 或==添加一个父指针==

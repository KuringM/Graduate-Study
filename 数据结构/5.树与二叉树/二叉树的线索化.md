# 二叉树的线索化

## 找结点的中序前驱

```c
//中序遍历
void findPre(BiTree T){
	if(T!=NULL){
		InOrder(T -> lchild); //递归遍历左子树
		visit(T); //访问根结点
		InOrder(T -> rchild); //递归遍历右子树
	}
}

//访问结点q
void visit(BiTNode *q){
	if (q==p) //当前访问结点刚好是结点p
		final = pre; //找到p的前驱
	else
		pre = q; //pre指向当前访问的结点
}

//辅助全局变量, 用于查找结点p的前驱
BiNode *p; //p指向目标结点
BiNode *pre=NULL; //指向当前访问结点的前驱
BiTNode *final=NULL; //用于记录最终结果
```

## 中序线索化

将一个序列, 按照中序线索二叉树构建.

```c
//全局变量 pre, 指向当前访问结点的前驱
ThreadNode *pre=NULL;

//线索二叉树结点
typedef struct ThreadNode{
	ElemType data;
	struct ThreadNode *child, *rchild;
	int ltag, rtag; //左、右线索标志
}ThreadNode, *ThreadTree;

//中序线索化二叉树
void CreateInThread(ThreadTree T){
	pre = NULL; //pre初始为NULL
	if (T!= NULL){ //非空二叉树才能线索化
		InThread(T); //中序线索化二叉树
		if (pre -> rchild == NULL)
			pre -> rtag = 1; //处理遍历的最后一个结点
	}
}

//中序遍历二叉树, 一边遍历一边线索化
void InThread(ThreadTree T){
  if (T != NULL) {
    InThread(T -> lchild);  //中序遍历左子树
    visit(T);            //访问根节点
    InThread(T -> rchild); //中序遍历右子树
  }
}

void visit(ThreadNode *q){
  if (q -> lchild == NULL) { //左子树为空, 建立前驱线索
    q -> lchild = pre;
    q -> ltag = 1;
  }
  if (pre != NULL && pre -> rchild == NULL) {
    pre -> rchild = q; //建立前驱结点的后继线索
    pre -> rtag = 1;
  }
  pre = q;
}
```

## 先序线索化

```c
//全局变量 pre, 指向当前访问结点的前驱
ThreadNode *pre=NULL;

//线索二叉树结点
typedef struct ThreadNode{
	ElemType data;
	struct ThreadNode *child, *rchild;
	int ltag, rtag; //左、右线索标志
}ThreadNode, *ThreadTree;

//先序线索化二叉树
void CreatePreThread(ThreadTree T){
	pre = NULL; //pre初始为NULL
	if (T!= NULL){ //非空二叉树才能线索化
		PreThread(T); //先序线索化二叉树
		if (pre -> rchild == NULL)
			pre -> rtag = 1; //处理遍历的最后一个结点
	}
}

//先序遍历二叉树, 一边遍历一边线索化
void PreThread(ThreadTree T){
  if (T != NULL) {
    visit(T);            //访问根节点
		if (T -> ltag=0) //lchild不是前驱线索, 否则存在原地打转现象
			PreThread(T -> lchild);
    PreThread(T -> rchild);
  }
}

void visit(ThreadNode *q){
  if (q -> lchild == NULL) { //左子树为空, 建立前驱线索
    q -> lchild = pre;
    q -> ltag = 1;
  }
  if (pre != NULL && pre -> rchild == NULL) {
    pre -> rchild = q; //建立前驱结点的后继线索
    pre -> rtag = 1;
  }
  pre = q;
}
```

### 后续线索化

```c
//全局变量 pre, 指向当前访问结点的前驱
ThreadNode *pre=NULL;

//线索二叉树结点
typedef struct ThreadNode{
	ElemType data;
	struct ThreadNode *child, *rchild;
	int ltag, rtag; //左、右线索标志
}ThreadNode, *ThreadTree;

//后序线索化二叉树
void CreatePostThread(ThreadTree T){
	pre = NULL; //pre初始为NULL
	if (T!= NULL){ //非空二叉树才能线索化
		PostThread(T); //后序线索化二叉树
		if (pre -> rchild == NULL)
			pre -> rtag = 1; //处理遍历的最后一个结点
	}
}

//后序遍历二叉树, 一边遍历一边线索化
void PostThread(ThreadTree T){
  if (T != NULL) {
		PostThread(T -> lchild);
    PostThread(T -> rchild);
    visit(T);            //访问根节点
  }
}

void visit(ThreadNode *q){
  if (q -> lchild == NULL) { //左子树为空, 建立前驱线索
    q -> lchild = pre;
    q -> ltag = 1;
  }
  if (pre != NULL && pre -> rchild == NULL) {
    pre -> rchild = q; //建立前驱结点的后继线索
    pre -> rtag = 1;
  }
  pre = q;
}
```

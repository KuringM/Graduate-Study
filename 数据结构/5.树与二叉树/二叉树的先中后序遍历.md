# 二叉树的先中后序遍历

- (线性)遍历: 按照某种次序把所有结点都访问一遍
- 层次遍历: 基于树的层次特性确定的次序规则
- 先/中/后序遍历: 基于树的递归特性确定的次序规则

二叉树的递归特性:

1. 要么是个空二叉树
2. 要么就是由"根节点+左子树+右子树"组成的二叉树

- 先序遍历: 根左右(NLR)
- 中序遍历: 左根右(LNR)
- 后序遍历: 左右根(LRN)

![[Pasted image 20250901141741.png]]

## 先序遍历

先序遍历(PreOrder)的操作过程如下:

1. 若二叉树为空, 则什么也不做;
2. 若二叉树非空:
   1. 访问根结点;
   2. 先序遍历左子树;
   3. 先序遍历右子树.

```c
//二叉树的结点(链式存储)
typedef struct BiNodet{
	ElemType data; //数据域
	struct BiTNode *lchild, *rchild; //左、右孩子指针
}BiTNode, *BiTree;

//先序遍历
void PreOrder(BiTree T)(
	if (T!=NULL){
		visit (T);            // 访问根结点
		PreOrder (T->child);  // 递归遍历左子树
		PreOrder (T->rchild); // 递归遍历右子树
	}
}
```

==空间复杂度: O(h)==

脑补空结点, 从根节点出发, 画一条路:

- 如果左边还有没走的路, 优先往左边走; 走到路的尽头(空结点)就往回走
- 如果左边没路了, 就往右边走
- 如果左、右都没路了, 则往上面走

先序遍历 -- 第一次路过时访问结点 ==(每个结点都会被路过3次)==

## 中序遍历

中序遍历(InOrder)的操作过程如下:

1. 若二叉树为空, 则什么也不做;
2. 若二叉树非空:
   1. 中序遍历左子树;
   2. 访问根结点;
   3. 中序遍历右子树.

```c
//中序遍历
void PreOrder(BiTree T)(
	if (T!=NULL){
		PreOrder (T->child);  // 递归遍历左子树
		visit (T);            // 访问根结点
		PreOrder (T->rchild); // 递归遍历右子树
	}
}
```

脑补空结点, 从根节点出发, 画一条路:

- 如果左边还有没走的路, 优先往左边走; 走到路的尽头(空结点)就往回走
- 如果左边没路了, 就往右边走
- 如果左、右都没路了, 则往上面走

中序遍历 -- 第二次路过时访问结点 ==(每个结点都会被路过3次)==

## 后序遍历

后序遍历(InOrder)的操作过程如下:

1. 若二叉树为空, 则什么也不做;
2. 若二叉树非空:
   1. 后序遍历左子树;
   2. 后序遍历右子树;
   3. 访问根结点.

```c
//后序遍历
void PreOrder(BiTree T)(
	if (T!=NULL){
		PreOrder (T->child);  // 递归遍历左子树
		PreOrder (T->rchild); // 递归遍历右子树
		visit (T);            // 访问根结点
	}
}
```

脑补空结点, 从根节点出发, 画一条路:

- 如果左边还有没走的路, 优先往左边走
- 走到路的尽头(空结点)就往回走
- 如果左边没路了, 就往右边走
- 如果左、右都没路了, 则往上面走

后序遍历 -- 第三次路过时访问结点 ==(每个结点都会被路过3次)==

## 遍历算法的应用举例

求树的深度(应用)

```c
int treeDepth (BiTree T){
	if (T== NULL) {
		return 0;
	}
	else {
		int l = treeDepth(T->lchild);
		int r = treeDepth(T->rchild);
		//树的深度 = Max(左子树深度, 右子树深度)+1
		return l>r ? l+1 : r+1;
	}
}
```

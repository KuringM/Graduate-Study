# 在线索二叉树中找前驱后继(线索二叉树的遍历)

|        | 中序线索二叉树 | 先序线索二叉树 | 后序线索二叉树 |
| :----: | :------------: | :------------: | :------------: |
| 找前驱 |       ✅       |       ❌       |       ✅       |
| 找后继 |       ✅       |       ✅       |       ❌       |

> ❌: 除非用三叉链表, 或者用土办法从根开始遍历寻找

## 中序线索二叉树找中序后继

在中序线索二叉树中找到指定结点 `*p` 的中序后继 `next`

1. 若 `p -> rtag==1`, 则 `next = p -> rchild` (**先序后继为右线索**)
2. 若 `p -> rtag==0`
   - `next` = ==p的右子树中最左下结点==

```c
//找到以P为根的子树中, 第一个被中序遍历的结点
ThreadNode *Firstnode(ThreadNade *p){
	//循环找到最左下结点(不一定是叶结点)
	while(p -> ltag==0) p=p -> lchild;
	return p;
}

//在中序线索二叉树中找到结点p的后继结点
ThreadNode *Nextnode(ThreadNode *p){
	//右子树中最左下结点
	if(p -> rtag==0) return Firstnode(p -> rchild);
	else return p -> rchild; //rtag==1直接返回后继线索
}

//对中序线索二叉树进行中序遍历(利用线索实现的非递归算法) -- 空间复杂度O(1)
void Inorder(ThreadNode *T){
	for(ThreadNode *p=Firstnode(T) ;p!=NULL; p=Nextnode(p))
		visit(p);
}
```

## 中序线索二叉树找中序前驱

在中序线索二叉树中找到指定结点 `*p` 的中序前继 `pre`

1. 若 `p -> ltag==1`, 则 `pre = p -> rchild`
2. 若 `p -> ltag==0`, 继续向下面的左孩子找可能存在的前驱
   - `pre` = ==p的左子树中最右下结点==

```c
//找到以P为根的子树中, 最后一个被中序遍历的结点
ThreadNode *Lastnode(ThreadNade *p){
	//循环找到最右下结点(不一定是叶结点)
	while(p -> rtag==0) p=p -> rchild;
	return p;
}

//在中序线索二叉树中找到结点p的前继结点
ThreadNode *Prenode(ThreadNode *p){
	//左子树中最右下结点
	if(p -> ltag == 0) return Firstnode(p -> lchild);
	else return p -> lchild; //ltag==1直接返回后继线索
}

//对中序线索二叉树进行逆向中序遍历
void RevInorder(ThreadNode *T){
	for(ThreadNode *p=Lastnode(T) ;p!=NULL; p=Prenode(p))
		visit(p);
}
```

## 先序线索二叉树找先序后继

在先序线索二叉树中找到指定结点 `*p` 的先序后继 `next`

1. 若 `p -> rtag==1`, 则 `next = p -> rchild` (**先序后继为右线索**)
2. 若 `p -> rtag==0` (p必有右孩子)
   - 若p有左孩子(`p -> ltag == 0`), 则==先序后继为左孩子==(`next = p -> lchild`)
   - 若p没有左孩子(`p -> ltag == 1`), 则==先序后继为右孩子==(`next = p -> rchild`)

![[截屏2025-09-02 05.47.45.png]]

## 先序线索二叉树找先序前驱

在先序线索二叉树中找到指定结点 `*p` 的先序前继 `pre`

1. 若 `p -> ltag==1`, 则 `pre = p -> rchild`
2. 若 `p -> ltag==0`
   - p必有左孩子, 先序遍历中, 左右子树中的结点只可能是根的后继, 不可能是前驱 -- 除非用土办法从头开始先序遍历
   - 或者改成**三叉链表**,添加一个**父结点**来遍历
     1. 如果能找到 p 的父节点, 且p是左孩子, ==p的父节点即为其前驱==
     2. 如果能找到 p 的父节点, 且p是右孩子, 其左兄弟为空, ==p的父节点即为其前驱==
     3. 如果能找到 p 的父节点, 且p是右孩子, 其左兄弟非空, ==p的前驱为左兄弟子树中最后一个被先序遍历的结点==
     4. 如果p是根节点, 则p没有先序前驱

## 后序线索二叉树找后序前驱

在后序线索二叉树中找到指定结点 `*p` 的后序前继 `pre`

1. 若 `p -> ltag==1`, 则 `pre = p -> lchild`
2. 若 `p -> ltag==0` (p必有左孩子)
   - 若p有右孩子, 则==后序前驱为右孩子==
   - 若p没有右孩子, 则==后序前驱为左孩子==

![[Pasted image 20250902061503.png]]

## 后序线索二叉树找后序后继

在后序线索二叉树中找到指定结点 `*p` 的后序后继 `next`

1. 若 `p -> rtag==1`, 则 `pre = p -> rchild`
2. 若 `p -> rtag==0` (p必有右孩子)
   - 后序遍历中, 左右子树中的结点只可能是根的前驱, 不可能是后继 -- 除非用土办法从头开始先序遍历
   - 改成**三叉链表**,添加一个**父结点**来遍历从头开始先序
     1. 如果能找到 p 的父节点, 且p是右孩子, ==p的父节点即为其后继==
     2. 如果能找到 p 的父节点, 且p是左孩子, 其右兄弟为空, ==p的父节点即为其后继==
     3. 如果能找到 p 的父节点, 且p是左孩子, 其右兄弟非空, ==p的后继为右兄弟子树中第一个被先序遍历的结点==
     4. 如果p是根节点, 则p没有后序后继


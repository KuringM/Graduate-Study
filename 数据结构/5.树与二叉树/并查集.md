# 并查集

## 逻辑结构--集合

![[Pasted image 20250902120203.png]]

- 将各个元素划分为若干个互不相交的子集
- 森林. 森林是 $m(m \geqslant 0)$ 棵互不相交的树的集合
- 如何**查**到一个元素到底属于哪一个集合? -- 从指定元素出发, 一路向北, 找到根节点.
- 如何判断两个元素是否属于同一个集合? -- 分别查到两个元素的根, 判断根节点是否相同即可.
- 如何把两个集合**并**为一个集合? -- 让一棵树成为另一棵树的子树即可.

## 并查集的存储结构

> 树的存储结构 -- 双亲表示法

![[截屏2025-09-02 12.24.58.png]]

### 并查集的基本操作

集合的两个基本操作 -- **并**和**查**

- Find --**查**操作: 确定一个指定元素所属集合
- Union --**并**操作: 将两个不想交的集合合并为一个

注: 并查集(Disjoint Set)是逻辑结构 -- 集合的一种具体实现, 只进行**并**和**查**两种基本操作.

## 并查集的代码实现

```c
#define SIZE 13
int UFSets[SIZE]; // 集合元素数组(双亲指针数组)

// 初始化并查集
void Initial(int S[]) {
  for (int i = 0; i < SIZE; i++)
    S[i] = -1;
}

// Find "查"操作, 找x所属集合(返回x所属根结点)
// 最坏时间复杂度 : O(n)
int Find(int S[], int x) {
  while (S[x] >= 0) // 循环寻找x的根
    x = S[x];
  return x; // 根的S[]小于0
}

// Union "并"操作, 将两个集合合并为一个
// 时间复杂度 : O(1)
void Union(int S[], int Rootl, int Root2) {
  // 要求Root1与Root2是不同的集合
  if (Root1 == Root2)
    return;
  // 将根Root2连接到另一根Root1下面
  S[Root2] = Root1;
}
```

## 并查集的优化

### Union 操作的优化

优化思路: 在每次Union操作构建树的时候, 尽可能让树不长高高

1. ==用根节点的绝对值表示树的结点总数==
2. ==Union操作, 让小树合并到大树==

![[截屏2025-09-02 12.49.44.png]]

```c
// Union "并"操作, 小树合并到大树
void Union(int S[], int Root1, int Root2) {
  if (Root1 == Root2)
    return;
  if (S[Root2] > S[Root1]) { // Root2结点数更少
    S[Root1] += S[Root2];    // 累加结点总数S[Root2]=Root1;//小树合并到大树
  } else {
    S[Root2] += S[Root1]; // 累加结点总数s[Root1]=Root2;//小树合并到大树
  }
}
```

- 该方法构造的树高不超过 $[\log_2 n] + 1$
- Union操作优化后, ==Find操作最坏时间复杂度 : $O(\log_2 n)$==

### Find 操作的优化(压缩路径)

压缩路径 -- Find 操作, 先找到根节点, 再将查找路径上所有结点都挂到根结点下.

![[截屏2025-09-02 13.06.23.png]]

```c
// rind"查"操作优化, 先找到根节点, 再进行"压缩路径"
int Find(int S[], int x) {
  int root = x;

  while (S[root] >= 0)
    root = S[root]; // 循环找到根

  while (x != root) { // 压缩路径
    int t = S[x];     // t指向x的父节点
    S[x] = root;      // x直接挂到根节点下
    x = t;
    return root; // 返回根节点编S号
  }
  S
}
```

> 核心思想: 尽可能让树变矮

每次 Find 操作, 先找根, 再 "压缩路径", 可使树的高度不超过 $O(\alpha(n))$.

- $\alpha(n)$是一个增长很缓慢的函数;
- 对于常见的n值, 通常$\alpha(n)\leqslant 4$,

因此优化后并查集的Find、Union操作时间开销都很低.

### 总结

![[Pasted image 20250902131948.png]]

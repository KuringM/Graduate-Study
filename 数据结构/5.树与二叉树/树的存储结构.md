# 树的存储结构

## 树的逻辑结构

![[树的定义#树]]

### 如何实现树的顺序存储?

树: 一个分支结点可以有多棵子树

==只依靠数组下标, 无法反映结点之间的逻辑关系==.

## 双亲表示法(顺序存储)

思路: 用数组顺序存储各个结点. 每个结点中保存数据元素、指向双亲结点(父节点)的**指针**.

- 优点: 找双亲(父节点)很方便.
- 缺点: 找孩子不方便, 只能从头到尾遍历整个数组.
  > 适用于"找父亲" 多, "找孩子" 少 的应用场景. 如: 并查集

![[Pasted image 20250902064302.png|800]]

```c
#define MAX_TREE_SIZE 100      //树中最多结点数

//树的结点定义
typedef struct{
	ElemType data; //数据元素
	int parent; //双亲位置域
}PTNode;

//树的类型定义
typedef struct{
  PNode nodes[MAX_TREE_SIZE]; //双亲表示
  int n; //结点数
}PTree;
```

![[Pasted image 20250902064740.png|800]]

## 孩子表示法(顺序+链式存储)

孩子表示法: 用数组顺序存储各个结点. 每个结点中保存**数据元素**、**孩子链表头指针**.

- 优点: 找孩子很方便
- 缺点: 找双亲(父节点)不方便, 只能遍历每个链表
  > 适用于"找孩子" 多, "找父亲" 少 的应用场景. 如: 服务流程树

![[Pasted image 20250902065754.png]]

```c
struct CNode{
	int child; //孩子结点在数组中的位置
	struct CNode *next; //一个孩子
}

typedef struct {
	ElemType data;
	struct CTNode *firstChild; //第一个孩子
}CTBox;

typedef struct{
	СТBoх nodes[MAX_TREE_SIZE];
	int n, r; //结点数和根的位置
}CTree;
```

![[Pasted image 20250902070047.png|800]]

## 孩子兄弟表示法(链式存储, 又称二叉树表示法)

树的孩子兄弟表示法, 与二叉树类似, 采用二叉链表实现. <BR>
每个结点内保存数据元素和两个指针, 但两个指针的含义与二叉树结点不同.

![[Pasted image 20250902070832.png]]

```c
//树的存储一孩子兄弟表示法
typedef struct SNode{
	ElemType data;
	struct CSNode *firstChild, *nextsibling; //第一个孩子和右兄弟指针
}CSNode, *CSTree;
```

当使用"孩子兄弟表示法"存储树或森林时, 从存储视角来看形态上与二叉树类似.
森林中每棵树的根节点视为平级的兄弟关系.

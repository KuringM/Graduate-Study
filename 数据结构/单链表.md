# 单链表

## 两种等价定义

```c
typedef struct LNode{ //定义单链表节点类型
	ElemType data; //数据域
	struct LNode *next; //指针域
}LNode, *LinkList;
```

等价于

```c
struct LNode{ //定义单链表节点类型
	ElemType data; //数据域
	struct LNode *next; //指针域
};

typedef struct LNode LNode;
typedef struct LNode *LinkList;
```

增加一个新节点: 在内存中申请一个节点所需的空间, 并用指针p指向这个节点.

```c
struct LNode *p = (struct LNode*)malloc(sizeof(struct LNode));
```

`typedef`数据类型重命名后写法更简单.

```c
LNode *p = ( LNode*)malloc(sizeof( LNode));
```

## 声明单链表

声明单链表时, 只需声明一个头指针L, 指向单链表的第一个节点.

```c
LNode *L; //声明一个指向单链表第一个结点的指针, 强调这是一个结点
```

或

```c
LinkList *L; //声明一个指向单链表第一个结点的指针 , 该声明代码刻度性更强, 强调这是一个单链表
```

## 单链表的初始化

### 1. 不带头结点的单链表

```c
typedef struct LNode{ //定义单链表节点类型
	ElemType data; //数据域
	struct LNode *next; //指针域
}LNode, *LinkList;

//初始化一个空的单链表
bool InitList(LinkList &L) {
	L = Null; //空表, 暂时无任何结点, //防止脏数据
	return true;
}

//判断单链表是否为空
bool Empty(LinkList L){
	if (L == NULL) return true;
	else return false;
	// 更简单写法
	// return (L == NULL);
}

void test(){
	LinkList L; //声明一个指向单链表的指针 // 并没有创建结点
	//初始化一个空表
	InitList(L);
	//...
}
```

### 2. 带头结点的单链表

> 头结点不存放数据

```c
typedef struct LNode{ //定义单链表节点类型
	ElemType data; //数据域
	struct LNode *next; //指针域
}LNode, *LinkList;

//初始化一个单链表(带头结点)
bool InitList(LinkList &L) {
	L = (LNode*) malloc(sizeof(LNode)); //分配一个头结点
	if (L==NULL) return false; //内存不足, 分配失败
	L->next = NULL; //头结点之后暂时没有结点
	return true;
}

//判断单链表是否为空(带头结点)
bool Empty(LinkList L){
	if (L -> NULL) return true;
	else return false;
	// 更简单写法
	// return (L == NULL);
}

void test(){
	LinkList L; //声明一个指向单链表的指针 // 并没有创建结点
	//初始化一个空表
	InitList(L);
	//...
}
```

## 按位序插入

### 按位序插入(带头结点)

```c
bool ListInsert(LinkList &L, int i, ElemTyep e){
	if(i<1) return false;
	LNode *p; // 指针p指向当前扫描到的结点
	int j=0; //当前p指向的是第几个结点
	p = L;
	while (p!=NULL && j<i-1){ //循环找到第 i-1 个结点
		p=p->next;
		j++
	}

	// LNode *p = GetElem(L, i-1)

	//在p结点之后插入元素e
	if(p==NULL) return false; //i值不合法
	LNode *s = (LNode*)malloc(sizeof(LNode));
	s->data = e;
	s->next=p->next; //将结点连接的原第i个结点
	p->next=s; //将结点连到p之后
	return true;
}
```

时间复杂度: O(n)

### 按位序插入(不带头结点)

```c
bool ListInsert(Link &L, int i, ElemTyep e){
	if(i<1) return false;
	if(i==1){ //插入第一个结点的操作与其他结点操作不同
		LNode *s = (LNode*)malloc(sizeof(LNode));
		s->data = e;
		s->next=L;
		L=s;
		return true;
	}
	LNode *p; // 指针p指向当前扫描到的结点
	int j=0; //当前p指向的是第几个结点
	p = L; //p指向第1个结点
	while (p!=NULL && j<i-1){ //循环找到第 i-1 个结点
		p=p->next;
		j++
	}

	//在p结点之后插入元素e
	// InsertNextNode(p, e)
	if(p==NULL) return false; //i值不合法
	LNode *s = (LNode*)malloc(sizeof(LNode));
	s->data = e;
	s->next=p->next; //将结点连接的原第i个结点
	p->next=s; //将结点连到p之后
	return true;
}
```

时间复杂度: O(n)

### 指定结点的后插操作

将上述代码中插入语句封装成函数

```c
//后插操作: 在p结点之后插入元素e
bool InsertNextNode (LNode *p, ElemTyep e){
	if(p==NULL) return false; //i值不合法
	LNode *s = (LNode*)malloc(sizeof(LNode));
	s->data = e;
	s->next=p->next; //将结点连接的原第i个结点
	p->next=s; //将结点连到p之后
	return true;
}
```

时间复杂度: O(1)

### 指定结点的前插操作

```c
//前插操作: 在p结点之前插入元素e
bool InsertPriorNode(LNode *p, ElemTyep e){
	if(p==NULL) return false; //i值不合法
	LNode *s = (LNode*)malloc(sizeof(LNode));
	if (s==NULL) return false; //内存分配失败
	s->next=p->next; //将s连接p的下个结点
	p->next=s; //将s结点连到p之后
	s->data=p->data;//将p中元素复制到s中
	p->data=e; //p中元素覆盖为e
	return true;
}
```

时间复杂度: O(1)

## 按位序删除(带头结点)

```c
bool ListDelete(LinkList &L, int i,ElemType &e) {
	if(i<1) return false;
	LNode *p; //指针p指向当前扫描到的结点
	int j=0; //当前p指向的是第几个结点
	p = L; //L指向头结点, 头结点是第0个结点(不存数据)
	while(p!=NULL && j<i-1){//循环找到第i-1个结点
		p=p->next;
		i-1=3 j++;
	}
	if(p==NULL)return false;
	if(p->next = NULL)return false;//第i—1个结点之后已无其他结点
	LNode *q=p->next;	//令q指向被删除结点
	e= q->data;//用e返回元素的值
	p->next=q->next; //将*q结点从链中"断开"
	free(q); //释放结点的存储空间
	return true;//删除成功
}
```

最坏、平均时间复杂度: O(n)
最好时间复杂度: O(1)

## 指定结点的删除

```c
bool DeleteNode(LNode *p){
	if(p==NULL)return false;
	LNode *q=p->next;	//令q指向*p的后继结点
	p->data=p->next->data;// *p和后继结点交换数据域 //若是最后结点,则存在bug
	p->next=q->next; //将*q结点从链中"断开"
	free(q); //释放后继结点的存储空间
	return true;//删除成功
}
```

## 按位查找

```c
LNode GetElem(LinkList L, int i){
	if(i<0) return NULL;
	LNode *p; // 指针p指向当前扫描到的结点
	int j=0; //当前p指向的是第几个结点
	p = L; //p指向第1个结点
	while (p!=NULL && j<i){ //循环找到第 i-1 个结点
		p=p->next;
		j++
	}
	return p;
}
```

## 按值查找

```c
LNode *LocateElem(LinkList L, int i){
	LNode *p= L->next;
	//从第一个结点开始查找数据域为e的结点
	while (p!=NULL && p->data != e)
	p = p->next;
	return p; //找到返回该结点指针, 否则返回NULL
}
```

## 求单链表长度

```c
int Length(LinkList L){
	int len = 0;
	LNode *p = L;
	while (p-> next!= NULL){
		p = p-> next;
		len++;
	}
	return len;
}
```

## 尾插法建立单链表

- TODO: Nomething <2025/07/21, Kuring> -

## 头插法建立单链表

- TODO: Nomething <2025/07/21, Kuring> -
